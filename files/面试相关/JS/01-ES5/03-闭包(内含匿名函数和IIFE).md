推荐阅读：
给代码问输出(很有意思)：https://juejin.im/post/6844903474212143117#heading-0

# 1.闭包定义

MDN 对于闭包的定义：【闭包】是指能够访问那些【自由变量】的函数。
[个人理解] 执行期间可以跨作用域访问变量的函数
[在红宝书中]：闭包是指有权访问另一个函数作用域中的变量的函数（闭包应该是基于词法作用域书写代码时产生的自然结果，是一种现象！）

自由变量：是指在函数中使用的，但既不是函数参数也不是函数内局部变量的变量

由此我们可以看出闭包共有两部分组成：
闭包 = 函数 + 函数能够访问的自由变量

如果照这个定义，那么所有的 JS 函数都是闭包。。。
但是其实这只是理论上的闭包，其实还有一个实践角度的闭包！这才是我们应该重点关注的对象！

# 2.ECMAScript 中，闭包指的是：

1.从理论角度：所有的函数。
因为它们都在创建的时候将上层上下文的数据保存起来了。哪怕是最简单的全局变量也是如此。
因为函数中访问全局变量就相当于是在访问自由变量，所以只要使用了外层的作用域，那么这个函数就是闭包了。

2.从实践角度：以下函数才算是闭包
//在红宝书中：闭包是指有权访问另一个函数作用域中的变量的函数（闭包应该是基于词法作用域书写代码时产生的自然结果，是一种现象！）

1. 即使创建它的上下文已经销毁，它仍然存在（比如，内部函数从父函数中返回）
2. 在代码中引入了自由变量
   //闭包的作用域链包含着它自己的作用域，以及包含它的函数的作用域和全局作用域。

---

# 3.闭包的常见写法：

(重!)即通过某种方式，将内部的函数传入到所在词法作用域之外，因为它持有对原始作用域的引用，所以产生了闭包！

## 3.1 函数中返回另一个函数

```js
function outerFn() {
  var a = 1;
  function innerFn() {
    consolo.log(a); //1
  }
  return innerFn;
}
var func = outerFn();
func();
```

## 3.2 函数中定义另一个函数，但是内部函数不由外部函数返回，而是将内部函数挂到全局变量上。

```js
var temp;
function outerFn() {
  var a = 1;
  function innerFn() {
    console.log(a); //1
  }
  temp = innerFn;
}
outerFn();
temp();
```

## 3.3 函数中定义另一个函数，但是内部函数不由外部函数返回，而是将其作为参数传给另一个函数

```js
function outerFn() {
  var a = 1;
  function innerFn() {
    console.log(a);
  }
  fn3(innerFn);
}
function fn3(fn) {
  fn();
}
outerFn();
```

# 3 闭包的注意事项

```text
1)闭包会导致内存泄漏
通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。
但是，在创建了一个闭包以后，这个函数的作用域在函数执行结束后并不会被销毁。
[注意JS的内存回收机制]
- 在 javascript 中，如果一个对象不再被引用，那么这个对象就会被垃圾回收机制回收；
- 如果两个对象互相引用，而不再被第 3 者所引用，那么这两个互相引用的对象也会被回收。
2)闭包只能取得包含函数中任何变量的最后一个值
```

# 4【匿名函数】

我们通常写的【匿名函数】都是【自执行】的，就是在匿名函数定义时将其后面加()，让其立即执行；
虽然匿名函数不能被其他对象调用，但是可以被其他函数调用啊，比如之前 setTimeout 中注册的回调函数。

匿名函数的执行环境具有全局性，因此其 this 对象大多数指向 window

------------------------------------------------------下面仅供了解-------------------------------------------------------------------

【深入闭包原理】—— 和执行上下文有关!

```js
var scope = "global scope";
function checkscope() {
  var scope = "local scope";
  function f() {
    return scope;
  }
  return f;
}

var foo = checkscope(); //原来是 checkscope()()
foo();
```

```text
具体执行过程见 07 的最后部分。这个过程中，出现了一个问题：
问题：
当 f 函数执行的时候，checkscope 函数上下文已经被销毁了啊，怎么还会读取到 checkscope 作用域下的 scope 值呢？
答案：
我们从具体执行过程当中可以看到，f 函数的执行上下文维护了一个作用域链：
fContext = {
Scope: [AO, checkscopeContext.AO, globalContext.VO]
}
对的，就是因为这个作用域链，f 函数依然可以读取到 checkscopeContext.AO 的值，
说明当 checkscopeContext.AO 中的值的时候，即使 checkscopeContext 被销毁了，
但是 JS 依然会让 checkscopeContext.AO 活在内存中，f 函数依然可以通过 f 函数的作用域找到它。


正是因为 JS 实现了这一点，从而实现了闭包这个概念！
所以，我们再看一遍实践角度上闭包的定义：
1.即使创建它的上下文已经销毁，它依然存在（比如，内部函数从父函数中返回）
2.在代码中引用了自由变量
```

---

两道必刷闭包题：
1.var data = [];
for (var i = 0; i < 3; i++) {
data[i] = function () {
console.log(i);
};
}
data[0]();  
 data[1]();
data[2](); //都为 3

2.var data = [];
for (var i = 0; i < 3; i++) {
data[i] = (function (i) {
return function(){
console.log(i);
}
})(i);
}
data[0]();
data[1]();
data[2](); //0 1 2

3.【arguments+闭包】经典面试题：
var data = [];
for(var i=0; i<3; i++){
(data[i] = function(){
console.log(arguments.callee.i)
}).i = i;
}
data[0](); //0
data[1](); //1
data[2](); //2
