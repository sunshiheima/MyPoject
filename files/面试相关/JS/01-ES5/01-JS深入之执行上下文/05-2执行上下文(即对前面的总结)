下面为"05-2对前面的总结-捋一捋"的缩略版，用于帮助理清思路,具体见文章

1.当函数被创建时：就保存作用域链到内部属性[[Scope]]

2.当全局代码执行到func();这一句时：不立即执行函数内部代码，而是先做准备工作 —— 即创建该函数的执行上下文，并将其压入执行上下文栈中

3.该函数执行上下文 初始化：
  1) 复制函数的[[scope]]属性以创建作用域链（目前还不是一个完整的作用域链）
  2) 创建活动对象（即AO），最初只包括arguments，随后初始化活动对象：加入形参、函数声明、变量声明（这里就涉及到了局部函数和局部变量的声明提升问题）
  3) 将活动对象压入该函数作用域链顶端（这句话是重点！显示出了活动对象(VO/AO)和作用域链(Scope)的关系
  
4.现在开始执行函数内部语句：
  1) 随着函数的执行，修改执行上下文中的AO的属性值
  2) 需要查找值的时候，去执行上下文中去找

5.最后，函数执行完毕：
  函数上下文从执行上下文栈中弹出

----------------------------------------------------------------------------------------------------------------------------------------
下面为"07-执行上下文(即对前面的总结)"的缩略版，用于帮助理清思路,具体见文章

下面分析这一段代码：
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        //return scope;
        console.log(scope);   //"local scope"
    }
    return f();   
}
checkscope();

执行过程如下：

-----------------------全局-------------------------------------

1.当进入全局环境时，暂不执行全局当中的代码，而是先做准备工作 —— 创建全局执行上下文，并将其压入执行上下文栈中

2.全局执行上下文 初始化：
  1.创建变量对象（即GO-window对象?），随后初始化变量对象：加入函数声明、变量声明（这里就涉及到了全局函数和全局变量的声明提升问题）    //这是我猜的！有待考证！
    window: {
       VO: {
         //函数和变量
       }
       Scope: [globalContext.VO]
    }
  ！全局执行上下文初始化的同时，checkscope函数被创建，保存作用域链到checkscope函数的自身属性[[scope]]
  //即checkscope.[[scope]] = [
      globalContext.VO
  ];

3.开始执行全局代码：
  1) 随着全局代码的执行，修改全局执行上下文中的VO的属性值
  2) 需要查找值的时候，从作用域链Scope的顶端开始查找（目前只有一个，即globalContext.VO）

--------------------checkscope函数------------------------------------

1.当执行到checkscope();这一句时，暂不执行函数内部代码，而是先做准备工作 —— 创建函数执行上下文，并将其压入执行上下文栈中

2.该函数执行上下文 初始化：
  1) 复制函数的[[scope]]属性以创建作用域链（目前还不是一个完整的作用域链）
  2) 创建活动对象（即AO），最初只包括arguments，随后初始化活动对象：加入形参、函数声明、变量声明（这里就涉及到了局部函数和局部变量的声明提升问题）
  3) 将活动对象压入该函数作用域链顶端（这句话是重点！显示出了活动对象(VO/AO)和作用域链(Scope)的关系
     checkscopeContext = {
           AO: {
               arguments: {
                   length: 0
               },
               //checkscope内部的函数和变量
           },
           Scope: [AO, [[Scope]]]
           //Scope：[AO, globalContext.VO]
     }
  ！checkscope初始化的同时：f函数被创建，保存作用域链到f函数的内部属性[[scope]]     
  //即f.[[scope]] = [
      checkscopeContext.AO,
      globalContext.VO
  ];

3.现在开始执行checkscope函数的内部语句
  1) 随着函数代码的执行，修改该函数执行上下文中的AO的属性值
  2) 需要查找值的时候，从作用域链Scope的顶端开始查找（先看AO当中有没有 => 看globalContext.VO当中有没有）

------------------------f函数------------------------------------------

1.当执行到f();这一句时，暂不执行函数内部代码，而是先做准备工作 —— 创建函数执行上下文，并将其压入执行上下文栈中

2.该函数执行上下文 初始化：
  1) 复制函数的[[scope]]属性以创建作用域链（目前还不是一个完整的作用域链）
  2) 创建活动对象（即AO），最初只包括arguments，随后初始化活动对象：加入形参、函数声明、变量声明（这里就涉及到了局部函数和局部变量的声明提升问题）
  3) 将活动对象压入该函数作用域链顶端（这句话是重点！显示出了活动对象(VO/AO)和作用域链(Scope)的关系
     fContext = {
           AO: {
               arguments: {
                   length: 0
               },
               //checkscope内部的函数和变量
           },
           Scope: [AO, [[Scope]]]
           //Scope：[AO, checkscopeContext.AO, globalContext.VO]
     }

3.现在开始执行f函数的内部语句
  1) 随着函数代码的执行，修改该函数执行上下文中的AO的属性值
  2) 需要查找值的时候，从该函数执行上下文fContext中，沿着作用域链Scope从顶端开始查找（先看AO中有没有 => 看checkscopeContext.AO当中有没有 => 看globalContext.VO当中有没有）

4.f函数执行完毕；
  f函数的执行上下文从执行上下文栈中弹出

----------------------继续checkscope函数----------------------------

4.继续执行checkscope函数中f();这一句之后的代码
  （但是此例当中不再需要了，因为f函数执行就是最后一句代码了）

5.checkscope函数执行完毕：
  checkscope函数的执行上下文从执行上下文栈中弹出

------------------------继续执行全局代码-----------------------------

4.继续执行全局中checkscope();这一句之后的代码






-----------------------------------------------------------------------------------------------------------------------------
下面为07留下的题，即分析下面代码，下面只是缩略版！

分析这一段代码：
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        //return scope;
        console.log(scope);   //"local scope"
    }
    return f;
}
var foo = checkscope();     //其实原来的写法是checkscope()()，一个道理，结果一样
foo();

简要的执行过程：
1.进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈
2.全局执行上下文初始化
  此过程中：checkscope函数被创建，保存作用域链到checkscope函数的内部属性[[scope]]
3.开始执行全局代码
---
4.到达checkscope()这一句，创建checkscope函数执行上下文，checkscope执行上下文被压入执行上下文栈
4.checkscope执行上下文初始化，创建变量对象、作用域链、this等
  此过程中：f函数被创建，保存作用域链到f函数的内部属性[[scope]]
5.开始执行checkscope内部代码，执行完毕将checkscope执行上下文从执行上下文栈中弹出
---
6.到达f()这一句，创建f函数执行上下文，f执行上下文被压入执行上下文栈
7.f执行上下文初始化，创建变量对象、作用域链、this等
8.开始执行checkscope内部代码，f函数上下文从执行上下文栈中弹出

上述这个过程太过简略，并不能说明输出结果，必须按照上面的详细步骤，分析得出每一个执行上下文中的具体内容，才能说明输出结果。
为什么这个函数的执行结果和上面函数的执行结果相同，关键就是：
  每一个执行上下文内部的作用域链Scope，都是静态的，即在函数定义时已经决定的；
  而我们查找值的时候，就是沿着作用域链Scope从顶端开始查找的；
  故f函数内部变量的值，不受f函数调用位置的影响，而只由f函数定义位置来决定！



