函数声明会提升的原因是：
    JS引擎并非会一行一行的分析和执行程序，而是一段一段的分析执行。
    当执行一段代码的时候，会进行一个“准备工作”，例如将变量提升，将函数声明提升。
    -这个“段”就是可执行代码，分为三种：全局代码、函数代码、eval代码
    -这个“准备工作”就是创建一个执行上下文。并且JS引擎会创建执行上下文栈来管理众多执行上下文

当【执行】一个函数的时候（注意不是函数声明时而是执行时！），就会创建一个执行上下文，并且压入执行上下文栈。
当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

--------------------------------------------------------------------------------

函数声明会提升的原因是：
    JS引擎并非会一行一行的分析和执行程序，而是一段一段的分析执行。
    当执行一段代码的时候，会进行一个“准备工作”，例如将变量提升，将函数声明提升。

那么这个“一段一段”中的“段”究竟是怎么划分的呢？
到底JS引擎遇到一段怎样的代码才会做“准备工作”了？

可执行代码
JS的可执行代码的类型就只有三种：全局代码、函数代码、eval代码
例如：当执行到一个函数的时候，就会进行准备工作.
      这里的“准备工作”，更专业的说法是--执行上下文(execution contexts)

执行上下文栈：
那么问题来了，我们写的函数多了去了，如何管理创建的那么多执行上下文呢？
所以JS引擎就创建了执行上下文栈(Execution context stack, ECS)来管理执行上下文

当【执行】一个函数的时候（注意不是函数声明时而是执行时！），就会创建一个执行上下文，并且压入执行上下文栈。
当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。

注意文章最后的“解答思考题”---即上篇文章《词法作用域和动态作用域》中最后的问题
答案：两段代码执行的结果一样，执行上下文栈的变化不一样。
      第一个是：push(外层函数) push(内层函数) pop() pop()
      第二个是：push(外层函数) pop() push(内层函数) pop()

