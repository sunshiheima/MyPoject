es3 es5 参照：https://juejin.cn/post/6844904158957404167#heading-21

# 1. 执行上下文类型

```text
1)全局执行上下文
2)函数执行上下文
3)Eval 函数执行上下文
```

## 1.1 全局执行上下文

这是默认或者说是最基础的执行上下文，一个程序中只会存在一个全局上下文，它在整个 javascript 脚本的生命周期内都会存在于执行堆栈的最底部不会被栈弹出销毁。全局上下文会生成一个全局对象（以浏览器环境为例，这个全局对象是 window），并且将 this 值绑定到这个全局对象上。

## 1.2 函数执行上下文

每当一个函数被调用时，都会创建一个新的函数执行上下文（不管这个函数是不是被重复调用的）

## 1.3 Eval 函数执行上下文

执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于并不经常使用 eval，所以在这里不做分析。具有安全风险。

# 2. ES3 执行上下文的内容

执行上下文是一个抽象的概念，我们可以将它理解为一个 object ，一个执行上下文里包括以下内容：

```text
1)变量对象
2)活动对象
3)作用域链
4)调用者信息
```

## 2.1 变量对象

变量对象（variable object 简称 VO

每个执行环境文都有一个表示变量的对象：变量对象，全局执行环境的变量对象始终存在，而函数这样局部环境的变量，只会在函数执行的过程中存在，在函数被调用时且在具体的函数代码运行之前，JS 引擎会用当前函数的参数列表（arguments）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的 变量 和 函数 将作为属性添加到这个变量对象上。

[！注意]只有函数声明（function declaration）会被加入到变量对象中，而函数表达式（function expression）会被忽略。
例如：

```js
// 这种叫做函数声明，会被加入变量对象
function a() {}
// b 是变量声明，也会被加入变量对象，但是作为一个函数表达式 _b 不会被加入变量对象
var b = function _b() {};
```

1)[全局上下文中的变量对象就是全局对象]，以浏览器环境来说，就是 window 对象。 2)[函数执行上下文中的变量对象内部定义的属性，是不能被直接访问的]，只有当函数被调用时，变量对象（VO）被激活为活动对象（AO）时，我们才能访问到其中的属性和方法。

## 2.2 活动对象

活动对象（activation object 简称 AO）

函数进入执行阶段时，原本不能访问的变量对象被激活成为一个活动对象，自此，我们可以访问到其中的各种属性。
[!注意]其实变量对象和活动对象是一个东西，只不过处于不同的状态和阶段而已。

## 2.3 作用域链

作用域链（scope chain）

```text

1)作用域

规定了如何查找变量，也就是确定当前执行代码对变量的访问权限。当查找变量的时候，会先从当前上下文的变量对象中查找，如果没有找到，就会从父级（词法层面上的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象。这样由多个执行上下文的变量对象构成的链表就叫做[作用域链]。

2)作用域链的创建

函数的作用域在函数创建时就已经确定了。当函数创建时，会有一个名为 [[scope]] 的内部属性保存所有父变量对象到其中。当函数执行时，会创建一个执行环境，然后通过复制函数的 [[scope]] 属性中的对象构建起执行环境的作用域链，然后，变量对象 VO 被激活生成 AO 并添加到作用域链的前端，完成作用域链创建完成。
```

```js
Scope = [AO].concat([[Scope]]);
```

## 2.3 调用者（this）

如果当前函数被作为对象方法调用或使用 bind call apply 等 API 进行委托调用，则将当前代码块的调用者信息（this）存入当前执行上下文，否则默认为全局对象调用。

# 2.4 执行上下文数据结构模拟

```js
executionContext：{
    [variable object | activation object]：{
        arguments,
        variables: [...],
        funcions: [...]
    },
    scope chain: variable object + all parents scopes
    thisValue: context object
}

```

# 3. ES3 执行上下文的生命周期

- 创建阶段
- 执行阶段
- 销毁阶段

## 3.1 创建阶段

```text
函数执行上下文的创建阶段，发生在函数调用时且在执行函数体内的具体代码之前，在创建阶段，JS 引擎会做如下操作：

1)用当前函数的[参数列表]（arguments）初始化一个 “变量对象” 并将当前执行上下文与之关联 ，函数代码块中声明的[变量]和[函数]将作为属性添加到这个变量对象上。

在这一阶段，会进行变量和函数的初始化声明，变量统一定义为 undefined 需要等到赋值时才会有确值，而函数则会直接定义且[比变量优先级高]。

2)构建作用域链（前面已经说过构建细节）
3)确定 this 的值
```

### 3.2 执行阶段

执行阶段中，JS 代码开始逐条执行，在这个阶段，JS 引擎开始对定义的变量赋值、开始顺着作用域链访问变量、如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出……

### 3.3 销毁阶段

一般来讲当函数执行完成后，当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权被重新交给执行栈上一层的执行上下文。

[!注意]这只是一般情况，闭包的情况又有所不同。

# 4. ES3 执行上下文总结

对于 ES3 中的执行上下文，我们可以用下面这个列表来概括程序执行的整个过程：

- 1)函数被调用
- 2)在执行具体的函数代码之前，创建了执行上下文
- 3)进入执行上下文的创建阶段：

  - 3.1)初始化作用域链
  - 3.2)创建 arguments object 检查上下文中的参数，初始化名称和值并创建引用副本
  - 3.3) 扫描上下文找到所有函数声明：

    - 3.3.1)对于每个找到的函数，用它们的原生函数名，在变量对象中创建一个属性，该属性里存放的是一个指向实际内存地址的指针
    - 3.3.2)如果函数名称已经存在了，属性的引用指针将会被覆盖

  - 3.4)扫描上下文找到所有 var 的变量声明：

    - 3.4.1)对于每个找到的变量声明，用它们的原生变量名，在变量对象中创建一个属性，并且使用 undefined 来初始化
    - 3.4.2)如果变量名作为属性在变量对象中已存在，则不做任何处理并接着扫描

  - 3.5)确定 this 值

- 4)进入执行上下文的执行阶段：
  - 4.1)在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。
