# 1.new 的四个步骤：

```text
1)创建一个新对象
2)将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）
3)执行构造函数中的代码（为这个新对象添加属性）
4)返回新对象
```

推荐使用：

# 2. 组合模式（组合构造函数模式和原型模式）

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = ["Mary"];
}
//Person.prototype.sayName = function(){ //我常用的写法！
// alert(this.name);
//}
Person.prototype = {
  constructor: Person, //使用这种写法会覆盖掉原来的 Person.prototype，所以需要手动修复 contructor 指向！
  sayName: function () {
    alert(this.name);
  },
};
var person1 = new Person("yf", 22);
var person2 = new Person("wyl", 23);
console.log(person1.friends === person2.friends); //false
```

优点：现在每个实例有其特有的属性了
缺点：Person 和 Person.prototype 分开了

# 3. 动态原型模式

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = ["Mary"];
  if (typeof this.sayName !== "function") {
    Person.prototype.sayName = function () {
      alert(this.name);
    };
  }
}
var person1 = new Person("yf", 22);
person1.sayName(); //"yf"
```

优点：将 Person.prototype 写在了 Person 里，实现了更好的封装！

# 4.了解项

## 4.1.工厂模式

```js
function createPerson(name) {
  var o = new Object();
  o.name = name;
  o.getName = function () {
    console.log(this.name);
  };
  return o;
}
var person1 = createPerson("kevin");
```

优点：解决了创建多个相似对象的问题
缺点：未解决对象识别的问题（即怎样知道一个对象的类型）

## 4.2 构造函数模式

```js
function Person(name, age){
this.name = name;
this.age = age;
this.sayName = function(){
alert(this.name);
}
}
var person1 = new Person("yf", 22);
var person2 = new Person("wyl, 23);
alert(person1.sayName === person2.sayName); //false
```

优点：能将实例标识为特定的类型，例如 person 实例的类型就是 Person。（person1.constructor == person | person1 instanceof Person）
缺点：每个实例中的方法指向不同（长得一样但实则不是同一方法）

## 4.3 构造函数模式优化（把方法定义转移到构造函数外部）

```js
function Person(name, age){
this.name = name;
this.age = age;
this.sayName = sayName;
}
function sayName(){
alert(this.name);
}
var person1 = new Person("yf", 22);
var person2 = new Person("wyl, 23);
alert(person1.sayName === person2.sayName); //true
```

优点：让每个实例的方法指向相同了
缺点：把方法定义在全局当中，导致我们自定义类型没有封装性了

---

## 4.4 原型模式（从本质上使实例方法指向相同）

```js
function Person() {}
Person.name = "yf";
Person.age = 22;
Person.sayName = function () {
  alert(this.name);
};
var person1 = new Person();
var person2 = new Person();
alert(person1.sayName === person2.sayName); //true
```

## 4.5 原型模式优化

```js
function Person() {}
Person.prototype = {
  //覆盖了原来的 Person.prototype
  name: "yf",
  age: 22,
  sayName: function () {
    alert(this.name);
  },
};
var person = new Person();
alert(person instanceof Person); //true，因为本质上是：person.**proto** 是否等于 Person.prototype
alert(person.constructor == Person); //false，因为本质上是：Person.prototype.constructor 是否等于 Person。（而此时 Person.prototype 被重写，contructor 属性丢失）
```

## 4.6 原型模式优化（解决上面 contructor 属性丢失的问题）

```js
function Person() {}
Person.prototype = {
  //覆盖了原来的 Person.prototype
  constructor: Person, //手动修复 constructor
  name: "yf",
  age: 22,
  sayName: function () {
    alert(this.name);
  },
};
var person = new Person();
alert(person instanceof Person); //true，本质上是：person.**proto** 是否等于 Person.prototype
alert(person.constructor == Person); //false，本质上是：Person.prototype.constructor 是否等于 Person。
```

优点：现在每个实例有共同的方法了
缺点：每个实例的属性也相同了（我们希望每个实例有其特有的属性）

---

4.7 组合模式

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = ["Mary"];
}
Person.prototype = {
  constructor: Person,
  sayName: function () {
    alert(this.name);
  },
};
var person1 = new Person("yf", 22);
var person2 = new Person("wyl", 23);
console.log(person1.friends === person2.friends); //false
```

优点：现在每个实例有其特有的属性了
缺点：Person 和 Person.prototype 分开了

4.8 动态原型模式

```js
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.friends = ["Mary"];
  if (typeof this.sayName !== "function") {
    Person.prototype.sayName = function () {
      alert(this.name);
    };
  }
}
var person1 = new Person("yf", 22);
person1.sayName(); //"yf"
```

---

5.1 寄生构造函数模式
5.2 稳妥构造函数模式

```

```
