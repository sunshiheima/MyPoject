ES6的类class，本质上就是ES5的构造函数。前者是后者的语法糖。

我们用构造函数去初始化对象，就是应用了【构造器模式】
【构造器模式】：抽象了每个对象实例的变与不变（解决的是多个对象实例的问题）
-不变的是每个员工都具备name、age、career这些属性，这是用户的共性
- 构造器将name、age、career 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变
-变的是每个user的name、age、career这些值，这是用户的个性
-构造器将 name、age、career 各自的取值操作开放，确保了个性的灵活

--------------------------------------------------------------------------------------------------

【简单工厂模式】：抽象不同构造函数/类之间的变与不变（解决的是多个类的问题）
-不变的是每个员工都具备name、age、career、work这些属性，这是用户的共性
-构造器User将name、age、career、work 赋值给对象的过程封装，确保了每个对象都具备这些属性，确保了共性的不变
-变的是每个user的name、age、career这些值 && work字段随career取值的不同而改变，这是用户的个性
-将【个性化的逻辑判断-即work字段随career取值的不同而改变】和【承载了共性的User类】写入工厂函数Factory，确保了个性的处理

//在写了大量构造函数、调用了大量的new时，我们就应该思考用【简单工厂模式】重构代码了。
//简单工厂模式的目的，就是为了实现“无脑传参”，爽！

--------------------------------------------------------------------------------------------------

【抽象工厂模式】：即复杂度从多个类上升到多个工厂共存时，使用一个超级工厂创建其他工厂。（解决的是不同工厂的问题）
开放[拓展]封闭[修改]原则：即软件实体(类、模块、函数)可以拓展，但是不可修改。	
//当我们需要添加功能时，我们首先想到的就是修改，这是错的，我们应该做的是【拓展】

抽象工厂模式模板的四个角色：（都是class)
-抽象工厂：即超级工厂，用于定规则（共性)。内含抽象类
-抽象类：不能被用于生成具体实例
-具体工厂：继承自抽象工厂，重写抽象工厂内部规定的抽象类->具体类。
-具体类：被用于生成具体实例

//用此模板我们就能轻松的实现拓展，而非直接修改原来的代码

注意：
抽象工厂目前在JS世界里应用的并不广泛，所以只需留意以下三点即可：
-学会用 ES6 模拟 JAVA 中的抽象类；
-了解抽象工厂模式中四个角色的定位与作用；
-对“开放封闭原则”形成自己的理解，知道它好在哪，知道执行它的必要性。


