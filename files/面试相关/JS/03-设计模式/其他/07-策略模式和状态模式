//这两种模式难度都不大，面试中也不常考，但是有助于培养【良好的编码习惯】和【重构意识】

策略模式：定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。
//算法：即询价逻辑，也可以是任何一个功能函数的逻辑
//封装：即把某一功能点对应的逻辑提出来
//可替换：建立在封装的基础上，这个“替换”的判断过程，不要直接怼if-else，而要考虑更优的映射方案。

状态模式：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。
//此定义较模糊，不必理会

策略模式和状态模式的同异：
策略模式和状态模式确实是相似的，它们都封装行为、都通过委托来实现行为分发。
-策略模式中的行为函数不依赖调用主体
-状态模式中的行为函数，首先是和状态主体之间存在着关联，由状态主体把它们串在一起；
 另一方面，正因为关联着同样的一个（或一类）主体，所以不同状态对应的行为函数可能并不会特别割裂。

【单一职责原则】：将做不同事的代码封装在不同的函数里面
【开放封闭原则】：对扩展开放，对修改封闭。将if-else改为对象映射。

原本的if-else，就是为了把[询价标签-询价函数]这个映射关系明确下来。
在JS中，有没有既能够帮我们明确映射关系，同时不破坏代码的灵活性的方法呢？ —— 【对象映射】

