Symbol的用处：
在ES5中，对象属性名都是字符串容易造成属性名冲突。为了避免这种情况的发生，ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。

【扩展运算符】和【剩余运算符】都是3个点(...)，后面跟着一个含有iterator接口的数据结构。区别是：
-扩展运算符：是将右边的数组拆分成元素的集合
-剩余运算符：是会收集这些元素集合，放到右边的数组中

-----------------------------

【扩展运算符】
在数组上使用扩展运算符，可以“展开”这个数组。
(数组是存放元素集合的一个容器，而使用扩展运算符可以将这个容器拆开，这样就只剩下元素集合，你可以把这些元素集合放到另外一个数组里面)
  
1.合并数组
//例1
let arr = [1,2,3,4,5];
let arr2 = [...arr, 6,7,8];   //[1,2,3,4,5,6,7,8]
//例2
let arr1 = [1,2,3];
let arr2 = [4,5,6];
console.log(arr1.concat(arr2));
console.log([...arr1, ...arr2]);

2.在对象中使用扩展运算符（这是ES9的语法）
//数组的扩展运算符原理是消耗所有迭代器，但对象中并没有迭代器，所以实现原理可能不同
let obj = {
    a: 1,
    b: 2,
    c: 3
}
let obj2 = {
    ...obj,
    d: 4
}
注意：
其实它和object.assign()类似（也是ES6新增的API），它们都可以合并对象
但是Object.assign()合并对象会触发目标对象的setter函数，而对象扩展运算符不会！

3.将类数组转为一个真正的数组
let nodeList = document.querySelectorAll('div');    
let arr = [...nodeList];

4.函数柯里化（具体见06-函数柯里化）

----------------------------------------

【剩余运算符】—— 替代了以前的arguments
-访问函数的arguments对象是一个很昂贵的操作，以前的arguments.callee,arguments.caller都被废止了，
-建议在支持ES6语法的环境下不要在使用arguments对象，使用剩余运算符替代
 (箭头函数没有arguments，必须使用剩余运算符才能访问参数集合)

1.常用于替代arguments:
function func1(...rest){
    console.log(rest);  //[1,2,3]
}
func1(1,2,3);

2.将剩余运算符和数组的解构赋值一起使用，注意必须放在最后一个！！！
-因为剩余运算符的原理其实是利用了数组的迭代器，它会消耗3个点后面的数组的所有迭代器，读取所有迭代器生成对象的value属性。
-剩运算符后不能在有解构赋值，因为剩余运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错。
let [first, ...arr] = [1,2,3,4,5];      //first会消耗右边数组的一个迭代器，...arr会消耗剩余所有的迭代器
first   //1
arr     //[2,3,4,5]
let [...arr, last] = [1,2,3,4,5];      //...arr直接消耗了所有迭代器，导致last没有迭代器可供消耗了，所以会报错
//Uncaught SyntaxError: Rest element must be last element


