ES6部分参考的文章：
1.这篇特别好！讲清楚了其他文章讲不清楚的难点！我的总结也很全，直接看总结即可！（部分可翻阅原文）
https://juejin.im/post/6844903775329583112#heading-27



---------------------------------------------------------------

ES6中常用的内容：
1.声明：var 对比 let const
2.箭头函数，函数的默认参数，解构赋值，扩展运算符...
4.内置对象：Set / SetWeak / Map / MapWeak
  (不常用的有：字符串扩展、数值扩展、对象扩展、数组扩展、函数扩展、正则扩展、Symbol、Reflect)

需要知道的概念：
1.异步编程： 从回调函数 -> generator -> promise -> Async/Await (你不知道的JS)
2.Iterator、Module、Class



-------------------------------------------------下面为常见的详解-----------------------------------
原文章https://juejin.im/post/5d9bf530518825427b27639d

1.作用域
ES5时只有【全局作用域】和【函数作用域】 --- function() {}
ES6有【全局作用域】、【函数作用域】、【块级作用域】 --- {}


2.var/let/const声明变量的区别：
1)const和let声明所在的区域会形成一个块级作用域！且会形成一个临时死区，在代码块内使用const和let声明变量之前，该变量不可用！
2)let声明的变量：在声明时赋值或之后赋值都可以；不允许重复声明；但是允许重新赋值
  const声明的常量：在声明的同时必须赋值；不允许重复声明；不允许重新赋值
3)var声明的变量会变量提升，而let和const声明的变量不会变量提升！


3.解构赋值
字符串、数值、布尔值、对象、数组、函数参数(函数的默认参数) 都可以解构
解构赋值应用的场景一般是：
1)交换变量值
2)提取JSON数据
3)定义函数参数默认值
4)导入模块具体某属性和方法

4.Set
定义：是类似于数组的数据结构，成员值都是唯一的值（也就是没有重复的）
声明：const set = new Set(arr);	//参数应该为【具有Iterator接口】的数据结构
属性：
	constructor: 构造函数，返回Set
	size: 返回实例成员总数
方法：
	add()：添加值，返回实例
	delete(): 删除值，返回布尔
	has(): 检查值，返回布尔
	clear(): 清除所有成员
	keys(): 返回以属性值为遍历器的对象
	values(): 返回以属性值为遍历器的对象
	entries(): 返回以属性值和属性值为遍历器的对象
	forEach(): 返回回调函数遍历每个成员
应用场景：
	去重字符串--[...new Set(str)].join("")]
	去重数组--[...new Set(arr)]或者Array.from(new Set(arr))

4-2.WeakSet
定义：和Set结构类似，但是成员值只能是对象
声明：const set = new WeakSet(arr);	//注意参数只能是【具有Iterator接口的】数据结构
属性：
	constructor : 构造函数，返回WeakSet
方法：
	add()：添加值，返回实例
	delete(): 删除值，返回布尔
	has(): 检查值，返回布尔
应用场景：
	存储DOM节点：DOM节点被移除时自动释放此成员，不用担心这些节点从文档移除时会引发内存泄漏的问题；
	临时存放一组对象或存放跟对象绑定的信息：只要这些对象在外部消失，它在WeakSet结构中的引用就会自动消失。

5.Map
定义：类似于对象的数据结构，成员键是任何类型的值
声明：const map = new Map(arr);	//注意参数只能是【具有Iterator接口】并且【每个成员都是一个双元素数组】的数据结构
属性和方法:
	和Set的属性和方法一样。

6.MapWeak
定义：和Map结构类似，成员键只能是对象
声明：const set = new WeakMap(arr);	//注意参数只能是【具有Iterator接口】并且【每个成员都是一个双元素数组】的数据结构
属性和方法：
	和SetWeak的属性和方法一样
	还多了has(): 检查键值对，返回布尔值
应用场景：
	存储DOM节点--DOM节点被移除时自动释放此成员键，不用担心这些节点从文档移除时会引发内存泄漏
	部署私有属性--内部属性是实例的弱引用，删除实例时它们也随之消失，不会造成内存泄漏


--------------------------------------------------------------------------------
其他：
Proxy：修改某些操作的默认行为
Reflect：保持Object方法的默认行为？
Class: 对一类具有共同特征事务的抽象



