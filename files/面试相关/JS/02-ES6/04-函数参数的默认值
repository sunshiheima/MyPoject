
1.函数默认值的前世今生
//ES5写法
function func(a){
    return a || 1
}
func(); //1
//ES6写法
function func(a=1){
    return a
}
func(); //1

2.函数默认值的特点
-如果使用了函数默认参数,在函数参数区域（即小括号里面），它会作为一个单独的块级作用域,并且拥有let/const声明的一些特性,比如暂时性死区。
-函数体中不能再对参数用let/const重复声明，且函数不能有同名参数？
-当传入的参数为undefined时才使用函数的默认值（显式传入undefined也会触发使用函数默认值，传入null则不会触发）
 let w = 1, z = 2;
 function func(x=w+1, y=x+1, z=z+1){
     console.log(x,y,z);    //Uncaught ReferenceError: z is not defined
 }
 func();
 //上面小括号中等同于
 {
     let x = w+1;   //通过词法作用域找到了变量w
     if(第一个实参 !== undefined){ x = 第一个实参 }

     let y = x+1;   //找到了上一行刚声明过的变量x
     if(第二个实参 !== undefined){ y = 第二个实参 }

     let z = z+1;   
     //先执行等号右边(z+1)，再把计算结果赋给等号左边let z
     //执行z+1时，会访问z的值，但此时z尚未声明，所以报错z is not defined
     if(第三个实参 !== undefined){ z = 第三个实参 }
 }
-设置函数默认值时引用的变量，做变量查询时是沿着词法作用域，会先从当前块级作用域（即小括号内）开始查找，若没有则在往函数的外部寻找该变量。最终找不到就会报错。
 而不会去函数体查找
 function bar(func = () => foo){    //func函数体内部，通过词法作用域只能访问当前作用域(无foo)、全局作用域(无foo)
     let foo = 'inner';
     console.log(func());   //bar函数体内部，可以通过词法作用域访问func函数、foo变量、this；
 }
 bar();   //ReferenceError: foo is not defined
-指定了默认值后，length属性将失真
 指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数
 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了

 
3.函数默认值配合解构赋值（三部曲）
-先看实参是否为undefined(没传也视作undefined)。若是则使用函数默认值（等号右边不变）；若不是则使用传入的实参（等号右边变为传入的实参）
-再看解构赋值{xxx} = {xxx}，将等号右边对应位置的值，赋给等号左边对应位置的变量
-若解构赋值之后，等号左边变量为undefined，则再看等号左边{}内是否设置了默认值，若是则将该默认值赋给该变量
function func({x=10}={}, {y}={y:10}){
    console.log(x, y);
}
func({}, {});                   //10,undefined
func(undefined, {});            //10,undefined
func(undefined, undefined);     //10,10
func();                         //10
func({x:1}, {y:2});             //1,2


