# 1.Symbol 的用处：

在 ES5 中，对象属性名都是字符串容易造成属性名冲突。为了避免这种情况的发生，ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。

# 2.【扩展运算符】和【剩余运算符】都是 3 个点(...)，后面跟着一个含有 iterator 接口的数据结构。区别是：

- 1)扩展运算符：是将右边的数组拆分成元素的集合
- 2)剩余运算符：是会收集这些元素集合，放到右边的数组中

---

# 3 【扩展运算符】

在数组上使用扩展运算符，可以“展开”这个数组。
(数组是存放元素集合的一个容器，而使用扩展运算符可以将这个容器拆开，这样就只剩下元素集合，你可以把这些元素集合放到另外一个数组里面)

## 3.1 合并数组

```js
//例 1
let arr = [1, 2, 3, 4, 5];
let arr2 = [...arr, 6, 7, 8]; //[1,2,3,4,5,6,7,8]
//例 2
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
console.log(arr1.concat(arr2));
console.log([...arr1, ...arr2]);
```

## 3.2 在对象中使用扩展运算符（这是 ES9 的语法）

数组的扩展运算符原理是消耗所有迭代器，但对象中并没有迭代器，所以实现原理可能不同

```js
let obj = {
  a: 1,
  b: 2,
  c: 3,
};
let obj2 = {
  ...obj,
  d: 4,
};
```

[注意]：
其实它和 object.assign()类似（也是 ES6 新增的 API），它们都可以合并对象
但是 Object.assign()合并对象会触发目标对象的 setter 函数，而对象扩展运算符不会！

## 3.3 将类数组转为一个真正的数组

```js
let nodeList = document.querySelectorAll("div");
let arr = [...nodeList];
```

## 3.4 函数柯里化（具体见 06-函数柯里化）

[剩余运算符]—— 替代了以前的 arguments

- 1)访问函数的 arguments 对象是一个很昂贵的操作，以前的 arguments.callee,arguments.caller 都被废止了，
- 2)建议在支持 ES6 语法的环境下不要在使用 arguments 对象，使用剩余运算符替代
  (箭头函数没有 arguments，必须使用剩余运算符才能访问参数集合)

### 3.4.1 常用于替代 arguments:

```js
function func1(...rest) {
  console.log(rest); //[1,2,3]
}
func1(1, 2, 3);
```

### 3.4.2 将剩余运算符和数组的解构赋值一起使用，注意必须放在最后一个！！！

- 1)因为剩余运算符的原理其实是利用了数组的迭代器，它会消耗 3 个点后面的数组的所有迭代器，读取所有迭代器生成对象的 value 属性。
- 2)剩运算符后不能再有解构赋值，因为剩余运算符已经消耗了所有迭代器，而数组的解构赋值也是消耗迭代器，但是这个时候已经没有迭代器了，所以会报错。

```js
let [first, ...arr] = [1,2,3,4,5]; //first 会消耗右边数组的一个迭代器，...arr 会消耗剩余所有的迭代器
first //1
arr //[2,3,4,5]
let [...arr, last] = [1,2,3,4,5]; //...arr 直接消耗了所有迭代器，导致 last 没有迭代器可供消耗了，所以会报错
//Uncaught SyntaxError: Rest element must be last element
```
