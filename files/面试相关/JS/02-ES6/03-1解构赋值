1.解构赋值的原理：
//作者猜测：是通过寻找相同的属性名，然后将原对象的这个属性名的值赋值给新对象对应的属性
let {
    title: titleOne,    //titleOne为一个变量，会被赋值为字符串abc
    test: [
        {
            title: titleTwo     //titleTwo为一个变量，会被赋值为字符串test
        }
    ]
} = {
    title: 'abc',
    test: [
        {
            title: 'test'
        }
    ]
}
解析：
这里左边真正声明的其实是titleOne,titleTwo这两个变量
然后会根据左边这2个变量的位置寻找右边对象中title和test[0]中的title对应的值
找到字符串abc和test赋值给titleOne,titleTwo（如果没有找到会返回undefined）

2.数组解构
原理：就是消耗数组的迭代器，把生成对象的value属性的值赋值给对应的变量。
用途：快速交换变量，避免以前要声明一个临时变量值存储值
      let a = 1;
      let b = 2;
      [a, b] = [b, a];      //等价于[a,b] = [2,1]  //右边数组会迭代，把生成的value属性的值赋给左边对应的变量，因此2会被赋给a，1会被赋给b
      a     //2
      b     //1

3.解构赋值的使用建议
1.当一个函数的参数为对象时，如果嵌套层数不多，建议使用解构赋值，可以减少形参的声明；但如果嵌套层数过多，则不适合用对象解构，不优雅
  //不使用对象解构，需要ctx这个形参的声明
  actions: {
      increment(ctx){
          ctx.commit('increment')
      }
  }
  //使用对象解构，不再需要ctx这个形参
  actions: {
      increment({commit}){
          commit('increment')
      }
  }

2.对axios的响应数据进行解构（axios默认会把真正的响应结果放在data属性中)
  let {data} = await axios.get("http://localhost: 3000");





