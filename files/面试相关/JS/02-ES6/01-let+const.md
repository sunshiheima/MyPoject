# 1.基础知识点

## 1.1 块级作用域

ES5 中作用域只有全局作用域和函数作用域。
到了 ES6，let/const 还能创建块级作用域。（即其所在的花括号内就是一个新的作用域）
外部是访问不到该块级作用域内用 let/const 声明的变量的。

## 1.2 if/for 结合 let/const 的使用注意：

使用时多存在于【if/for 结合 let/const】创建的块级作用域。注意使用 let/const 声明变量的 for 循环和 var 声明的有些不同。

- 1)for 循环:
  for 循环包含两大块：小括号中的为[设置循环变量部分]，大括号中的为[循环体部分];
  实则：[设置循环变量部分]是一个父作用域，而[循环体部分]是一个单独的子作用域，所以我们可以在循环体内部访问到 i 的值。
  for 循环[设置循环变量部分]又包含 3 个部分：第一部分包含一个变量声明，第二部分包含一个循环的退出条件，第三部分包含每次循环最后要执行的表达式。后面的两个部分在每次循环时都会执行一遍。区别在于变量声明。
- 2)使用 var 声明循环变量：
  只会声明一次
- 3)使用 let 声明循环变量：
  每次循环都会声明一次
  每一次循环的 i 其实都是一个新的变量，JavaScript 引擎内部会记住上一轮 i 的值，初始化本轮的 i 时，会上一轮循环的基础上进行计算。

## 1.3 暂时性死区

一个变量，仅仅在创建之后还不能用（用了会报错），在初始化之后才能用。 所谓的“用”，就是访问/修改
从[创建]到[初始化]之间的代码就形成了[暂时性死区]，已经被创建的变量不能在这段代码内被访问或修改。

[简述]：
var 声明的变量：在预编译阶段就会[被创建]并且被[初始化为'undefined']；在代码执行阶段会[重新赋我们指定的值]
let/const 声明的变量：在预编译阶段只会[被创建]，不会被初始化；在代码执行阶段在声明语句（"let name"）之前，均不会被[初始化]。
因此在声明语句之前，会形成[暂时性死区]，即不能访问或修改 let/const 声明的变量。
只有当执行到声明语句时，若是 let 声明的且没有赋值，就会默认初始化为 undefined；若是 const 声明的且没有赋值，则会报错。
let 和 const 都不能重复声明

## 1.4 let 和 const 的区别：

[let]：在声明的时候可以不赋值，那么默认初始化为 undefined。后面还可以重新赋值（但不能重新声明）。
[const]： 在声明的时候必须被赋值，且赋值之后变量指向的内存地址不能被改变（不能再使用赋值运算符改变）

- 1)若赋予的是一个基本类型，那么所谓内存地址也就是该基本类型的值；
- 2)-若赋予的是一个引用类型，那么内存地址实则为一个对象的引用。只要保证该内存地址不变即可，引用的对象还可以改变（对属性增删改）。
  即可以对属性增删改，但不能直接使用赋值运算符更改，因为这种更改本质上会改变内存地址引用的那个对象。

另外：let 和 const 声明的变量不会变为全局变量（即不会被挂到 window 上，故不会污染全局变量空间）
[扩展]：其实 let 声明的变量是在一个叫 script 作用域下的

# 2.下面供深挖时参考

## 2.1【临时性死区】具体概述：

1.var 声明的变量，在代码执行到什么的时候：
1).先进入预编译阶段：会创建什么作用域、什么环境、name 变量。
name 变量还会提升到当前函数作用域的顶部（如果"var name"是在全局作用域下,则 name 变量会直接提升到全局作用域），并且【赋值】为 undefined
//故 var 声明的变量在预编译时，会被创建并赋值为 undefined
2).进入代码执行阶段：当运行到"name = 'abc'"这句代码时，name 变量会被重新赋值为'abc'

## 2.2 因为使用了 let 声明了变量 name，因此在代码执行到 if 语句的时候：（重点！）

1).先进入预编译阶段：一次创建块级作用域、词法环境、name 变量（创建了但是没有初始化）
2).进行代码执行阶段：只有运行到“let name”这一句代码时变量才被初始化并赋值为 undefined。
但是在这一句代码之前 name 变量仅仅被创建了（在预编译阶段）但是未被初始化。在此之前使用该变量

## 2.3 下面为有疑惑的部分

文中描述，意思就是[3.临时性死区]的意思

let/const 也有提升的作用，但是和 var 的区别在于：

- var 在[创建]时就被[初始化]，并且赋值为 undefined
- let/const 在进入块级作用域后，会因为提升的原因先[创建]，但不会被初始化，直到声明语句执行时才被[初始化]。
  初始化时如果使用 let 声明的变量没有赋值，则会默认赋值为 undefined；而 const 必须在初始化的时候赋值，否则会报错。

边解释边执行、预编译、执行？
什么叫声明提升？其本质究竟是什么？

var 的缺陷：变量提升、污染全局变量等

需要去查：JS 预编译 && JS 的三种作用域（全局、函数、块级）

---
