两篇文章差不多，区别就是代码实现稍有不同，可以都看看！里面还有一些链接资源(MDN等)也需要多看看！
参考自：https://segmentfault.com/a/1190000018081475
掘金上还有一篇类似的：https://juejin.im/post/6844903589123457031#heading-12
这篇文章也很不错！https://juejin.im/post/6844903842643968014

路由的概念来源于服务端
-在服务端中，路由描述的是URL与处理函数之间的映射关系。
-在Web前端单页应用SPA中，路由描述的是URL与UI之间的映射关系，这种映射是单向的，即URL变化引起UI更新（无需刷新页面）
有很多独立的第三方路由系统，主流的前端框架也都有自己的路由，例如React有React-router

单页面应用SPA开发模式，在路由切换时替换DOM Tree中最小修改的部分DOM，来减少原先因为多页应用跳转带来的巨量性能损耗。
各种路由插件总是提供两种不同方式的路由：hash和history，有时也会提供非浏览器环境下的路由方式Abstract

Hash和History的区别：
-外观上的不同
-Hash方式的状态保存需要另行传递；而HTML5 History原生提供自定义状态传递的能力，可以直接利用其来传递信息。

---------------------------------【Hash】---------------------------------

原理：
-通过监听#后的URL路径标识符的更改而被触发的浏览器hashchange事件；
-通过获取location.hash得到当前的路径标识符，再进行一些路由跳转的操作

相关API：
-location.href：返回完整的URL
-location.hash：返回URL的锚部分
-location.pathname：返回URL路径名
-hashchange事件：当location.hash发生改变时，将触发这个事件

注意：
Hash方法是利用了相当于页面锚点的功能，所以与原来的通过锚点定位来进行页面滚动定位的方式冲突，导致定位到错误的路由路径。
因此需要采用别的方法。

---------------------------------------------------------------------------

//初始化，即实例化RouterClass类，且使得该实例存放在window.Router属性上
RouterClass.init();
//为每一个路径，注册待执行的回调函数
window.Router.route(输入路径, 输入跳转到该路径时要执行的回调函数)
//声明一个render函数，作用就是【根据当前路径，得到其下注册的回调函数并执行】
//当window的onload事件触发时，即页面第一此挂载完毕时，会调用render函数
//当window的onhashchange事件触发时，即点击链接页面跳转时，会调用render函数

--------------------------------------------------------------------------

使用脚本来控制Hash路由的后退，可以将经历的路由记录下来
路由后退跳转的实现是对location.hash赋值，这样就会重新引发hashchange事件，再次调用render。
所以我们需要增加一个标志位，来标明进入render方法是因为回退进入还是用户跳转。

当点击页面中的"back"按钮时，会调用window.Router.back()
//将标志位isBack()置为true
//移除当前hash，回退到上一个
//拿到要回退到的目标hash，将其赋值给location.hash使得触发onhashchange事件从而调用render函数
//render函数内部，看到标志位为true，不做任何事情只是将标志重置为false
//back()内部的代码继续执行，【根据当前路由，调用其下注册的回调函数】—— 这件事不再归render来做：可能是因为需要prev这个变量，如果交给render则还需要向render传参。

--------------------------------【History】--------------------------------------

相关API：
-history.go(n)：路由跳转，n为2-表示往前移动2个页面，n为-2表示向后移动2个页面，n为0表示刷新页面。
-history.back()：路由后退，相当于history.go(-1)
-history.forward()：路由前进，相当于history.go(1)
-history.pushState()：添加一条路由历史记录，如果设置跨域网址则报错
-history.replaceState()：替换当前页在路由历史记录的信息
-popstate事件：当活动的历史记录(即history对象)发生变化，就会触发popstate事件。在点击浏览器的前进后退按钮或者调用上面前三个方法时也会触发。

pushState():
在某种意义上，调用pushState()与设置window.location = "#foo"类似，二者都会在当前页面创建并激活新的历史记录。
1.接收的参数：
-状态对象：一个JS对象。可以是被序列化的任何东西，大小限制为640k，若所需空间更大则建议使用sessionStorage或localStorage
 //当用户导航到一个新状态时(即history对象改变时)，popstate事件就会被触发，且popstate.state属性包含状态对象的副本。popstate事件触发时，该对象会传入回调函数？
-标题：Firefox目前忽略此参数，暂时设为null即可
-URL：定义新的历史URL记录。不传此参数则默认为当前URL
 //调用pushState()后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如用户重新打开浏览器时。
 //可以为绝对路径/相对路径(默认相对于当前URL)；新URL必须和当前URL同源，否则会抛出异常。

2.pushState的优点：
-新的URL可以是与当前URL同源的任意URL。
 而window.location默认设置的就是当前页面的哈希值而已！其前面的路径都不会变
-可以设置和当前相同的URL。
 而window.location ="#xxx"，只有当xxx不为当前哈希值时，才能创建新的历史记录项
-可以将任意数据和新的历史记录项相关联。
 而基于哈希，要把所有相关数据编码为短字符串
-如果[标题]随后还会被浏览器所用到，那么这个数据是可以被使用的。
 而哈希则不是

注意：pushState()绝对不会触发hashchange事件！

注意：仅仅调用pushState()/replaceState()时，并不会触发popstate事件，只有用户点击浏览器倒退按钮和前进按钮 / 使用JS调用back、forward、go方法时 才会触发。

--------------------------------

Hash模式：是使用URL的Hash来模拟一个完整的URL，因此当URL改变时页面并不会重载。
History模式：则会直接改变URL，所以在路由跳转时会丢失一些地址信息，在刷新或直接访问路由地址时会匹配不到静态资源。
            因此需要在服务器上配置一些信息，让服务器增加一个覆盖所有情况的候选资源，比如跳转到index.html（一般来说是app依赖页面）
