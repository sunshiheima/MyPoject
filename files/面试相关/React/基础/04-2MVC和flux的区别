MVC框架把应用分为三个部分：
1.Controller(控制器)：根据用户输入调用对应的Model部分逻辑；把产生的数据结果交给View部分，让View渲染出必要的输出。
2.Model(模型)：负责管理数据，大部分业务逻辑也应该放在Model中
3.View(视图)：负责渲染用户界面，应该避免在View中涉及业务逻辑

一个Flux应用包含四个部分：
1.Dispatcher(相当于Controller)：处理动作分发，维持store之间的依赖关系
2.Store(相当于Model)：负责存储数据和处理数据相关逻辑
3.Action：驱动Dispatcher的JS对象
4.View(相当于View)：视图部分，负责显示用户界面

当需要扩充应用所能处理的“请求”时，MVC方法就需要增加新的Controller，而对于Flux则只是增加新的Action

--------------------------------------------------

MVC框架提出的数据流很理想，用户请求先到达Controller，由Controller调用Model获得数据，然后把数据交给View。
但是，在实际框架实现中，总是允许View和Model可以直接通信(级即无法禁绝它们之间直接通信)，但是这样应用很快就会变得复杂。

而Flux和Redux:
Store只有get方法，没有set方法，根本不可能直接去修改其内部状态。
View只能通过get方法获取Store的状态，无法直接去修改状态。如果View想要修改Store状态的话，只有派发一个action对象给Dispatcher
这看起来是“限制”，但却是一个很好的“限制”，禁绝了数据流混乱的可能。

-----------------------------------------------------
补：服务端的MVC框架和浏览器端的MVC框架的区别：
服务端的MVC框架：
    往往就是每个请求就只在Controller-Model-View三者之间走一圈，结果就返回给浏览器去渲染或者其他处理了。
浏览器端的MVC框架：
    因为存在用户交互处理，界面渲染出来之后，Model和View依然存在于浏览器中，
    这时候就会诱惑开发者为了简便，让现存的Model和View直接对话




