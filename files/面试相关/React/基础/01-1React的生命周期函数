
1.装载阶段(/初始化，此阶段的结果是：用户在网页上可以看到组件的第一印象)
    constructor     一个React组件需要构造函数，往往是处于以下目的：
                    1.初始化state,因为有状态组件生命周期中任何函数都可能要访问state
                    2.绑定成员函数的this环境(在构造函数中，this指向 当前组件实例)
                    ！无状态组件的React组件往往就不需要构造函数，
                    -----
                    即ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。

    getInitialState 这两个函数返回值都可以作为props的初始值，这个是只出现在装载过程中的，即组件的整个生命周期中该函数只会被调用一次，不要在里面放置预期会被多次执行的代码！
    getDefaultProps ！这两个函数只有在React.createClass方法创造的时候才会用到，在ES6的方法定义的React组件中根本不会用到！

    componentWillMount  ！此函数发生在“将要装载”的时候，这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制
                        ！注意：通常不用定义此函数，能在此函数中做的事情，都可以提前到constructor中

    render          ！render函数并不做实际的渲染动作，它只是返回一个JSX描述的结构。最终由React来操作渲染过程。
                    ------
                    1.如果render函数返回一个null或者false, 等于告诉React，这个组件不需要渲染任何DOM元素。
                    2.一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对除render之外的生命周期函数都有默认实现
                    3.注意render函数应该是一个纯函数，完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。因此不应该在render中调用this.setState

    componentDidMount   ！render被调用完之后，componentDidMount函数并不是被立即调用。而是等render函数返回的东西都已经引发了渲染，组件已经被装载到了DOM树上时，componentDidMount才会被调用
                        ！在实际的应用当中，我们通常会在此函数当中：
                          1).通过AJAX获取数据来填充组件的内容。
                          2).进行DOM操作。因为在componentDidMount被调用的时候，组件已经被装载到DOM树上了！
                        ------
                        做一个实验，我们会发现，虽然componentWillMount都是紧贴着自己组件的render函数；但是当所有三个组件的render函数被调用之后，三个组件的componentDidMount才会连在一起被调用
                        原因：render函数本身并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象如何渲染。
                             而React库肯定是要把所有组件返回的结果综合起来，才能知道该如何产生对应的DOM修改。
                             所以，只有React库调用三个Counter组件的render函数之后，才有可能完成装载，这时候才会依次调用各个组件的componentDidMount函数作为装载过程的收尾
                        ------
                        另：componentWillMount和componentDidMount还有一个区别：就是Will既会在浏览器端被调用又会在服务器端被调用；而Did只会在浏览器端被调用
                            原因是：既然“装载”是一个创建组件并放到DOM树上的过程，那么真正的“装载”是不可能在服务器端完成的，因为服务器端渲染并不会产生DOM树，通过React组件产生的只是一个存粹的字符串而已。

2.更新阶段(此阶段：让该组件可以随着用户操作改变展现的内容)
    componentWillReceiveProps    只要父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程。关于这个函数我们还要注意：
                                 1.不管父组件传给子组件的props有没有改变，都会触发子组件的componentWillReceiveProps函数
                                 2.通过this.setState方法触发的更新过程不会调用这个函数
                                 3.我们可以在此函数当中将nextProps和this.prop做对比，来决定是不是要更新组件的内部状态state
                                 ----------------
                                 此函数适合根据新的props值（即参数nextProps）来计算出是不是要更新组件的内部状态state，具体做法是：
                                 在这个函数里面把传入参数nextProps(代表这一次渲染传入的props值)和this.props(上一次渲染时的props值)做必要对比，只有两者不相等的时候才有必要调用this.setState更新内部状态。

    shouldComponentUpdate       说render函数很重要，是因为它决定了该渲染什么，其返回结果将用于构造DOM对象；
                                说shouldComponentUpdate很重要，是因为它决定了一个组件什么时候不需要渲染，其返回结果为一个布尔值，告诉React库这个组件在这次更新过程中是否要继续。
                                如果我们不自己写shouldComponentUpdate函数，那就沿用所有React组件的父类React.Component中的默认方式，默认实现方式就是返回true，即每次更新过程都要重新渲染。
                                为了更高的性能，我们需自己定制此函数：定义只有当props或者state改变的时候，才引发组件的重渲，否则就中断。
                                shouldComponentUpdate  (nextProps, nextState){
                                    return (nextProps.caption !== this.props.caption || nextState.count !== this.state.count)
                                }
                                当调用this.setState函数引发了更新过程时，并不是立刻更新组件的state值，而是先去执行shouldComponentUpdate函数

    componentWillUpdate
    render
    componentDidUpdate          之前说到可以在componentDidMount函数中执行其他UI库的代码，比如jQuery代码。
                                当React组件被更新时，原有的内容被重新绘制，这时候就需要componentDidUpdate函数再次调用jQuery代码
                                ----
                                此函数既能在浏览器端执行，也能在服务器端执行（但是一般在服务器端，就算定义了也一般不会执行，如果执行了证明你的代码有点儿问题需要改进）

3.卸载过程
  componentWillUnmount          ！当组件要从DOM树上删除掉之前，对应的componentWillUnmount函数会被调用，所以这个函数适合做一些清理性的工作
                                ！componentWillUnmount中的工作往往和componentDidMount有关，比如：在componentDidMount中用非React得方法创造了一些DOM元素
                                  如果撒手不管可能会造成内存泄露，那就需要在componentWillUnmount中把这些创造得DOM元素清理掉



其他：
1.每个React组件都可以通过this.forceUpdate()函数强行引发一次重新绘制。
2.在JSX中写匿名函数赋值给onClick的方法--onClick={()=>{...}}。看起来非常简洁而且方便，其实并不是值得提倡的做法
  因为每次渲染都会创造一个新的匿名方法对象，而且有可能引发子组件不必要的重新渲染。
3.render函数和shouldComponentUpdate函数是所有生命周期中唯二要求有返回结果的函数！

--------------------------------

衍生问题：【应该在Ract组件的何处发起Ajax请求？】

在React组件中，应该在componentDidMount中发起网络请求。
因为componentDidMount这个生命周期是在生成DOM树（挂载）完成之后才会调用的。
如果我们尝试在挂载之前例如componentWillMount来进行AJAX请求，然后把请求拿到的结果setState。
这就意味着我们尝试在一个未挂载的组件上调用setState，这将不起作用。

除了能在componentDidMount中发起AJAX请求，
如果我们需要在React当中使用其他UI库，例如jQuery，例如绘制图标的d3.js，也需要利用componentDidMount
因为当componentDidMount执行时，React组件对应的DOM已经存在，所有的事件处理函数也已经设置好。
这时候就可以调用jQuery的代码，让jQuery代码在已经绘制的DOM基础上增强新的功能。

