【JS线程、Event Loop、事件队列、任务队列（宏任务+微任务）】
这篇文章很好，通俗易懂！文章内容和我理解的相符合。如果遗忘了，可以再看看！
https://juejin.im/post/6844903752621637645#heading-15

宏任务和微任务：
常见的宏任务有：script(整体代码)、setTimeout、I/O操作、UI渲染、requestAnimation、网络请求
常见的微任务有：promise、process.nextTick(node.js环境)

代码执行流程大概是：
1)先将一个宏任务出队，执行某宏任务当中的同步代码（注意Promise在初始化时，传入的函数是同步执行的）
2)再将此宏任务当中的一队微任务出队并执行
3)执行渲染操作，更新界面
4)处理worker相关的任务
5)进行下一轮事件循环（将下一个宏任务出队并执行）

1.【渲染的时机】—— 【如果我想要在异步任务里进行DOM操作，应该将其包装成微任务】
因为script本身是一个宏任务，本次执行完script脚本的同步任务和微任务之后，会触发render更新页面；
若将DOM操作放入另一个宏任务中，那么本次render实则是无效的，需等到下一次render才会生效！
Promise.resolve().then(task);

2.异步更新策略（Vue和React中）
异步更新：
    当我们使用Vue或React提供的接口去更新数据时，这个更新并不会立即生效，而是会被推入到一个队列里。
    待到适当的时机，队列中的更新任务会被批量触发。

Vue中的nextTick函数：要更新状态时，会先把这个更新操作包装成一个异步操作派发出去
-默认是用Promise包装的，则异步操作就是一个微任务，会在本次事件循环末尾执行
-如果一定将异步操作变为宏任务，则就用setTimeout包装

具体过程：
Vue中每产生一个状态更新任务，它就会被塞进一个叫callbacks的数组（此处是任务队列的实现形式）中。
这个任务队列在被丢进micro或macro队列之前，会先去检查当前是否有异步更新任务正在执行（即检查pending锁）。
如果确认pending锁是开着的（false），就把它设置为锁上（true），然后对当前callbacks数组的任务进行派发（丢进micro或macro队列）和执行。


