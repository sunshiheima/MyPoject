//图片优化特别特别重要！！！是前端性能优化必不可少的部分！！！
图片优化 —— 权衡【压缩图片体积】和【牺牲部分成像质量】

Web图片格式有：
JPEG/JPG 、 PNG 、  SVG 、雪碧图(CSS Sprites)和Base64 、 WebP

前置知识：
计算机中像素是用二进制表示的，不同图片格式中，像素和二进制位数之间的对应关系不同。
一个像素对应的二进制位数越多，它表示的颜色种类就越多，成像效果越细腻，文件体积相应越大。
一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。

------------

1.JPEG/JPG 
有损压缩、体积小、加载快、不支持透明
虽然有损，但仍是高质量的压缩方式。其压缩之后的颜色数足以应对大多数场景下对色彩的要求，如果用对了地方其压缩前后的质量损耗不容易被肉眼察觉。

适用场景：
JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG 图片经常作为大的背景图、轮播图或 Banner 图出现。
缺点：
它处理矢量图形和 Logo 等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。
JPEG 图像不支持透明度处理。

------------

2.PNG（8/24）
无损压缩、质量高、体积大、支持透明
尽量使用PNG-8，如果效果达不到预期就换成PNG-24

使用场景：
用它来呈现小的 Logo、颜色简单且对比强烈的图片或背景等。

------------

3.SVG（可缩放矢量图形）
文本文件兼容性好、图片可无限放大而不失真、体积更小可压缩性更强

//简介和使用方式
SVG（可缩放矢量图形）是一种基于XML语法的图像格式。SVG对图像的处理不是基于像素点，而是是基于对图像的形状描述。
SVG是文本文件。我们既可以像写代码一样定义SVG，把它写在HTML里、成为DOM的一部分。也可以把对图形的描述写入以.svg为后缀的独立文件。所以兼容性好（SVG文件在使用上与普通图片文件无异）。

缺点：
渲染成本比较高，性能不好
可编程故学习成本较高

//实际开发中（重!)
设计师会给我们SVG文件，或者有非常好用的【在线矢量图片库】
对于矢量图我们无需深究过多，了解即可

-----------

4.雪碧图和Base64 —— 小图标解决方案
雪碧图：一种将小图标和背景图像合并到一张图片上，使得使用一个图像文件替代多个小文件。然后利用CSS的背景定位来显示其中的每一部分的技术。

Base64是作为雪碧图的补充：
Base64是一种用于传输8Bit字节码的编码方式，通过对图片进行Base64编码，我们可以直接将编码结果写入HTML或者写入CSS。
浏览器是可以理解这个字符串的，它自动就将这个字符串解码为了一个图片，而无需再发送HTTP请求。
//Base64会带来文件体积膨胀（4/3）

Base64的应用场景：
1.图片的实际尺寸很小（一些小图标）
2.图片无法以雪碧图的形式与其它小图结合（Base64是作为雪碧图的补充）
3.图片的更新频率非常低（即无需重复编码和修改文件内容）

Base64编码工具推荐：
webpack的【url-loader】，除了基本的Base64转码能力，还可以结合文件大小，帮我们判断图片是否有必要进行Base64编码。

------------

5.WebP —— 集各种图片文件格式的优点于一身，但是兼容性可怕（只有chrome兼容）
像JPEG一样适合细节丰富的图片，像PNG一样支持透明，像GIF一样可以显示动态图片

缺点：
-兼容性差（只有chrome兼容）码同样质量的WebP文件会占用更多的计算资源。

具体应用：
先进行了兼容性的预判，在浏览器环境支持WebP的情况下，优先使用 WebP格式，否则就把图片降级为JPG格式（本质是对图片的链接地址作简单的字符串切割）
//另一种方法：把判断工作交给后端，由服务器根据HTTP请求头部的Accept字段来决定返回什么格式的图片。




