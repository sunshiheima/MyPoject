前端工程化是为了让前端可以自成体系，具体可以从四方面去讨论，模块化，组件化，规范化和自动化。
1.模块化：在资源和代码方面对文件的拆分。将大的文件拆分成互相依赖的小文件，再进行统一的拼装和加载。
//js的模块化
利用webpack+babel的模式将所有模块系统进行打包，同步加载，也可以搭乘多个chunk异步加载。
利用浏览器的script标签，type类型选modules类型即可。
//css模块化
最被认可的是css modules，所有的css文件由js来管理，这种技术最大程度利用了css的生态和模块化的原则，其中vue中的scoped 就是这种技术的提现。
//资源模块化
webpack也能将资源模块化。
2.组件化：在UI层面进行的拆分。将UI页面拆分正有模板+样式+逻辑组成的功能单元。
3.规范化：项目前期规范制定的好坏，直接决定后期的开发质量，分为项目目录规范化，编码规范化，前后端接口规范化，git分支管理等等
4.自动化：让简单重复的工作交给机器完成，例如自动化测试，自动化部署，自动化构建，持续继承等。
	从最早先的 grunt、gulp 等，再到目前的 webpack、parcel

WebGL：3D绘图协议
小程序
WebAssembly：
跨端：

-----------------------------------------

1.loader和plugin的区别

2.文件监听原理：
轮询判断文件的最后编辑时间是否变化，如果某个文件发生了变化，并不会立刻告诉监听者，而是先缓存起来，等 aggregateTimeout 后再执行。（设置多久检查一次）
Webpack开启监听模式，有两种方式：
-启动 webpack 命令时，带上 --watch 参数
-在配置 webpack.config.js 中设置 watch:true
缺点：每次需要手动刷新浏览器

3.Webpack的热更新原理：
这个机制可以做到不用刷新浏览器而将新变更的模块替换掉旧的模块。核心就是客户端从服务端拉去更新后的文件.
-实际上webpack-dev-server与浏览器之间维护了一个 Websocket
当本地资源发生变化时，webpack-dev-server会向浏览器推送更新，并带上构建时的hash，让客户端与上一次资源进行对比。
-客户端对比出差异后会向webpack-dev-server发起Ajax请求来获取更改内容(文件列表、hash)，
这样客户端就可以再借助这些信息继续向webpack-dev-server发起jsonp请求获取该chunk的增量更新。
-后续的部分(拿到增量更新之后如何处理？哪些状态该保留？哪些又需要更新？)由 HotModulePlugin 来完成，react-hot-loader也是借助这些API来完成的

4.如何优化webpack构建速度：
-多进程构建
-压缩代码、压缩图片
-缩小打包作用域
-提取页面公共资源
-充分利用缓存提升二次构建速度

