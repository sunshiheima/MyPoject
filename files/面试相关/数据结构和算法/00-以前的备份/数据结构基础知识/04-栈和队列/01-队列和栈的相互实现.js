/*在数组中，我们可以通过索引随机访问元素，但是在某些情况下，我们可能要限制数据的访问顺序，于是有了两者限制访问顺序的数据结构：栈（先进后出）、队列（先进先出）*/

/*
  用两个栈来实现一个队列，完成队列的push和pop操作。队列中的元素为int类型
  思路：
    栈1模仿入队列--因为数据只能从队列的尾部进入，数据只能从栈的顶部进入。而栈的顶部就相当于队列的尾部。因此数据入队列这个操作，就实现为--向栈1当中push元素 即可
    栈2模仿出队列--因为数据只能从队列的头部移出，数据只能从栈的顶部移出。而栈的顶部不等于队列的头部，相反栈的底部才等于队列的头部。
                  因此我们需要先将栈1的元素pop出来，然后push进栈2,这样就将栈1中的元素倒序了，这样栈2的顶部就相当于栈1的底部。
                  这样数据出队列这个操作，就实现为--将栈2当中的元素pop出来  即可

  总结：
    模拟"元素入队列"--即：让元素入栈1
    模拟"元素出队列"--即：先让栈1当中的元素pop出来，再push进栈2；然后将栈2当中的元素pop出来。这样就模拟了元素出队列了。

  注意：栈2为空才能补充栈1的数据，否则会打乱当前的顺序
  但是我感觉应该是（注意结合示意图看）：栈2不为空时，可以将数据push进栈1，但是不能试图移除出数据（因为数据移出需要将栈1的数据放到栈2当中，但是当栈2还未空时，时不能将新的数据放入的！）
*/
const stack1 = [];
const stack2 = [];

function push(node){
  stack1.push(node);
}
function pop(){
  if(stack2.length === 0){
    while(stack1.length>0){
      stack2.push(stack1.pop());
    }
  }
  return stack2.pop() || null;
}

/*拓展：用两个队列实现一个栈，没说思路。。。自己画图想或者百度吧。。。*/
const queue1 = [];
const queue2 = [];





























