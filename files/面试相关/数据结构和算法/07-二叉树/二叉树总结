重新理解二叉树时

​1.常规二叉树中所有题，都已经模拟了一遍递归的入栈出栈的过程。注意：
1）迭代法实现二叉树先后序遍历和中序遍历，只要按照思路来做即可——栈
2）层序遍历​，也按照思路来即可——队列
"层序遍历变体​"只是在"层序遍历"基础上，往while和其内部代码中间加了【for循环】和【level初始化】而已。作用是：将当前层的元素放入level当中。
3）翻转二叉树——递归(栈）
​通自己用栈来模拟递归代码的执行流程，我发现这个翻转过程是自底向上的。理清执行流程的关键就是—要清楚每一次入栈出栈函数中root代表的节点。
​4）先中后序遍历递归版。(代码类似于翻转二叉树）
我理了一下先序遍历​递归代码的执行流程，同样关键也是—要清楚也是root代表的节点。
注意：3的结尾需要return root，这是因为​自底向上翻转二叉树的同时也是在构造出新的二叉树；但是2就不需要了，其递归的目的只是为了控制console节点的顺序而已。

2.二叉搜索树(递归代码都很直观。就是背！)
1）查找值为某一特定值的节点，这是利用了二叉搜索树的(左节点<根节点<右节点)的特性，比较简单。
   但是若在题中return root，为什么最终为undefined了？
2）插入新节点
   注意，往二叉树当中插入某个节点，该节点的插入位置可以有好几种选择，题目中选择的插入位置是能让我们更方便插入的位置！
   只需在1的基础上添加if(!root){ root = new TreeNode(n) }
   但为什么代码执行结果为undefined了？
3）删除指定节点
   在1的基础上，当n===root.val时，添加删除逻辑即可
   注意需要覆盖 + 递归删除（理解重点！）
   
   