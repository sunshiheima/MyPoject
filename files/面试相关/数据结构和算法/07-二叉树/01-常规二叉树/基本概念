树的基本概念
（其中节点的概念有：节点的高度、度、叶子节点；整棵树的概念有：树的层次/深度、树的高度）
1.树的层次（深度）：根节点所在的那一层记为第一层，其子节点所在的就是第二层，以此类推。
2.节点的高度和树的高度：
  叶子节点高度计为1，每向上一层高度就加1，逐层向上累加至目标节点，所得到的值就是目标节点的高度。
  树中节点的最大高度，称为“树的高度”
3.度：一个节点开叉出来多少个子树，被记为节点的度。
4.叶子节点：叶子节点就是度为0的节点。

二叉树的定义：
1.它可以没有根节点，作为一颗空树存在
2.如果它不是空树，那么【必须由根节点、左子树、右子树组成，且左右子树都是二叉树】
3.二叉树它的左子树或右子树可以为空（如果定义左子树和右子树一定要存在的话，那么就是满二叉树了）
注意:
    【二叉树不能被简单定义为每个节点的度都为1的树】
    因为普通的树并不会区分左子树和右子树，但在二叉树中，左右子树的位置是严格约定、不能交换的！


树、二叉树、满二叉树(完全二叉树)、平衡二叉树、二叉搜索树的概念？


1.迭代法实现二叉树的先、中、后序遍历
2.二叉树层序遍历的衍生问题
3.翻转二叉树

其实通过使用递归，我们可以把原本复杂的东西，拆解成非常简单的、符合人类惯用脑回路的逻辑
将三序遍历的迭代法和递归法比较一下，你就会发现递归的“真香”

二叉树题目给我们的输入和输出：
输入看似是一个数组，实则不是。谨记，二叉树题目的输入只要没有额外强调，那么一般来说它都是基于一个嵌套对象而来的！！！
如果里面要求输出一个遍历序列，那么输出的应为一个真数组，而非二叉树。因此随后需要塞入结果数组的不是节点对象，而是节点的值！

迭代法进行【二叉树先序遍历】的根本思路：
就是通过合理安排入栈和出栈的时机、使栈的出栈序列符合二叉树的前序遍历原则
先序遍历的规则是：先遍历根节点、然后遍历左孩子、最后遍历右孩子 —— 这正是我们所期望的出栈序列。
按道理，入栈序列和出栈序列相反，我们似乎应该按照“右->左->根”这样的顺序将节点入栈。
但是需要注意的是，我们遍历的起点就是根节点，难道我们要假装没看到这个根节点，一鼓作气找到最右侧节点之后才开始进行入栈操作吗？—— 不是！！！
实际的出入栈顺序：
1.将根节点入栈
2.取出栈顶节点，将节点值push进结果数组
3.若栈顶节点有右孩子，则将右孩子入栈
4.若栈顶节点有左孩子，则将左孩子入栈。
简言之：将当前子树的根节点入栈、出栈，随后再将其对应右子树入栈、将左子树入栈，然后出栈push到结果数组。最后结果数组中就是【根, 左子树, 右子树】

迭代法先序和后序的区别：
先序代码：根进栈出栈进res，右左分别进栈（所以出栈是左右，注意出栈顺序即进res的顺序！）；又因为是按顺序push进res的，所以res为根、左、右
后序代码：根进栈出栈进res，左右分别进栈（所以出栈是右左，注意出栈顺序即进res的顺序！）；又因为是按顺序unshift进res的，所以res为左、右、根

注意：
当连续多个数字进栈，然后再连续多个出栈时，出栈顺序一定和入栈顺序相反
但是只有在push进res的时候，res中的顺序才会和出栈顺序看起来一样；
当unshift进res的时候，res中的顺序和出栈顺序看起来会相反

const root = {
  val: "A",
  left: { val: "B", left: { val: "D" }, right: { val: "E" } },
  right: { val: "C", right: { val: "F" } },
};
console.log(xxx(root));