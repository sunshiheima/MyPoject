/*
https://juejin.im/book/6844733800300150797/section/6844733800358871048

题目：给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集
示例：
    输入：nums = [1,2,3]
    输出：[[],[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]

分析：
    穷举出现了，大概率会用到DFS —— 树形思维方式（关键：对坑位的定位和分析）
    全排列问题：
        -不变：坑位数 —— 某层
        -变化：进入坑位的数字 —— 分叉依据
    子集问题：
        -不变：可以参与组合的数字 —— 某层
        -变化：每个数字在组合中的存在性 —— 分叉依据

子集问题也不是靠人脑就能想出来的递归代码，记忆即可。
我已经将程序执行流程想了一遍，预想的输出顺序和代码实际执行之后的输出顺序一致。
重！
    但是这个输出顺序和文中画的树形结构没有什么关联（而全排列问题和相应的树形图的先序排列 的遍历输出顺序一致）
    我猜可能是作者画的树形结构有问题？ —— 不是，是此解法执行流程与该图不匹配！
    我去leetcode上搜了一下解法，发现有很多种：【递归回溯法】、【迭代法】、【二叉树的三序遍历法】，文中用的就是【递归回溯法】！
    每一种解法的输出顺序各有不同！我个人认为如果要和那个树形图关联起来的话，【二叉树的三序遍历法】会更加直观！
    但是这种leetcode上的【二叉树的三序遍历法】我并没有看懂，也不知道如何自己写出来~~~

注意此题的递归边界！
    这道题中，我们并没有显式的return语句来标示递归边界的存在。
    这个边界的判定被for语句偷偷的做掉了：for语句会遍历所有的数字，当数字遍历完全时，也就意味着递归走到了尽头！

*/

//文中代码
// 入参是一个数组
const subsets = function (nums) {
  // 初始化结果数组
  const res = [];
  // 缓存数组长度
  const len = nums.length;
  // 初始化组合数组
  const subset = [];
  // 进入 dfs
  dfs(0);

  // 定义 dfs 函数，入参是 nums 中的数字索引
  function dfs(index) {
    // 每次进入，都意味着组合内容更新了一次，故直接推入结果数组
    res.push(subset.slice());
    // 从当前数字的索引开始，遍历 nums
    for (let i = index; i < len; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(nums[i]);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};

const subsets = function (nums) {
  const res = [];
  const len = nums.length;
  const subset = [];
  dfs(0);
  function dfs(index) {
    res.push(subset.slice());
    for (let i = index; i < len; i++) {
      subset.push(nums[i]);
      dfs(i + 1);
      subset.pop();
    }
  }
  return res;
};
