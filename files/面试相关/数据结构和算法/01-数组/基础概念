出自掘金小册【前端算法和数据结构面试】

1.【数组对应的是连续内存，但在JS中不一定是】
  -如果在一个数组中只定义了一种类型的元素，如const arr = [1,2,3,4]，是一个纯数字数组，那么对应的确实是连续内存
  -但是如果定义了不同类型的元素，如const arr = ['haha', 1, {a: 1}]，那么对应的就是一段非连续的内存。
    此时，JS数组不再具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的

---------------------------------------------------------

双指针法用在涉及求和、比大小类的数组题目里时，大前提往往是：该数组必须有序。
若给的数组无序，则双指针根本无法帮助我们缩小定位的范围，压根没有意义。
因此我们需要先给数组排序，再才让双指针帮助我们！！！

什么时候你需要联想到“对撞指针”？
当出现两个关键字 —— “有序”和“数组”时，首先应该立即想到双指针（普通双指针）
如果普通双指针走不通，立刻就要像“对撞指针”！！！

---------------------------------------------------------

基本概念：
    数组是一种线性数据结构，它用一组连续的内存空间，来存储一组具有相同类型的数据。
    (线性数据结构有：数组、链表、队列、栈；非线性数据结构有：二叉树、堆、图等。)

特点：
    数组最大的特点就是支持随机访问，但插入、删除操作也因此变得低效，平均时间复杂度为O(n)
    (而链表则相反：链表适合插入、删除，时间复杂度为O(1))

小技巧：
    1.插入
    如果要往有序数组中插入元素（到某位置k），则必须搬移k之后的数据，则平均时间复杂度为O(n)
    -----
    但是：如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合。
    在这种情况下，如果要将某个数据插入到第k个位置，为了避免大规模的搬移，还有一个简单的方法就是：
    ！直接将第k为的数据搬移到元素的最后，把新的元素直接放入第k个位置。
    -----
    利用这种处理技巧，在特点的场景下，在第k个位置插入一个元素的时间复杂度就会降为O(1)

    2.删除
    和插入数据类似，如果我们要删除第k个位置的元素，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。故删除操作的时间复杂度也为O(n)
    -----
    实际上，在某些特殊场景下，我们并不一定追求数组中数据的连续性。
    如果我们把多次删除操作集中在一起执行，删除的效率是不是会提高很多了？
    ！我们让每次删除操作并不是真正的搬移数据，只是记录数据已经被删除。当数组没有更多空间存储数据时，我们再触发执行一次真正的搬移操作。这样就大大减少了删除操作导致的数据搬移问题。
    -----
    这也是JVM标记清除回收算法的核心思想


问：为什么很多编程语言中数组都从0开始编号了？
答：从数组的内存模型上看，"下标"最确切的定义应该是"偏移offset"，如果用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址。
    a[k]_address = base_address + k * type_size;
    若从1开始，那么公式中k -> k-1,那么对于CPU来说就是多了一次减法指令。

------------------------------------------------------------------------------------
练习题：
双指针问题：
1.调整数组顺序使奇数位于偶数前面：首尾指针
2.和为S的两个数字（注意和两数之和区分开）：首尾指针
3.三数之和：确定一个基准数 + 首尾指针
4.四数之和：确定两个基准数 + 首尾指针，其边界条件判断太多，暂时只是了解即可
5.和为S的连续正整数序列：虽然也是双指针，但不是首尾指针，两指针都是从头开始的

构建map(值作为key下标作为值）
1.两数之和：一次循环即可
2.数组中出现次数超过数组长度一半的值：一次循环即可
3.第一此只出现一次的字符：两次循环

二维数组：（此类问题常建模：用矩阵）
1.构建乘积数组
2.顺时针打印矩阵（有点难，暂略）

其他：（这个下面的题目，只需要记住这个题自身所用的技巧即可，这种技巧不是通用的，只是能够巧妙地简化思维）
1.连续子数组的最大和
2.扑克牌顺子



