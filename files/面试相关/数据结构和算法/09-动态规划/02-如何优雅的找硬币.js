/*
题目：
    给定不同面额的硬币 coins 和一个总金额 amount。
    编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

分析：最值问题+无需具体硬币组成 => 用动态规划
难点：
    //f(n)：参数n-需要组成的总金额；结果-凑成n所需的最少的硬币个数
    1)状态转移方程不好确定
      和爬楼梯一样"站在第n阶楼梯上的后退姿势" => 站在amount这个组合结果上的"后退姿势".
      假设使用c1、c2、...cn分别来表示题目中给我们的第1-n个硬币。
      那么f(36) = Math.min(f(36-c1)+1, f(36-c2)+1, f(36-c3)+1, ..., f(36-cn)+1);
    2)边界条件不好确定
      f[0] = 0;  
    3)递归转迭代
      我认为的此题最大的难点!!! 还是没懂。。。

const f = [];
const findMin = function(coins, amount){
    if(amount===0){
        return 0;
    }
    return 
}

//输入coins为[1,2,5];amount为11 => 输出3(11=5+5+1)
const findMin = function(coins, amount){
    //【记忆化搜索】用于保存每个目标总额对应的最小硬币个数
    const f = [];
    //确定边界条件
    f[0] = 0;
    //递归转迭代

    
}
