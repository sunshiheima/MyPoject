文章很好，条理清晰无废话，值得重看！
https://juejin.im/post/6844903833387155464
关键字：内存泄漏的概念、js垃圾回收机制、内存泄漏的情况、内存泄漏的识别方法、垃圾回收的使用场景优化

---------------------------------内存泄漏的概念----------------------------------------

【内存泄漏】
程序的运行需要内存。只要程序提出要求，操作系统或者运行时就必须供给内存。
内存泄漏：指的就是不再用到的内存，没有及时释放。

【更好的避免内存泄漏】—— 【垃圾回收机制】
在C/C++语言中，开发人员可以直接控制内存的申请和回收。
在Java/C#/JavaScript语言中，变量的内存空间的申请和释放都由程序自己处理，开发人员不需要关心。

---------------------------------js的垃圾回收机制-----------------------------------------

所以JS就有【自动垃圾回收机制】
-找出不再使用的变量，然后释放掉其占用的内存。
-但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。

【垃圾回收机制的必要性】
-由于字符串、对象和数组没有固定大小，所有当他们的大小已知时，才能对他们进行动态的存储分配。
-JavaScript程序每次创建字符串、数组或对象时，解释器都必须分配内存来存储那个实体。
-只要像这样动态地分配了内存，最终都要释放这些内存以便他们能够被再用。
 否则，JavaScript的解释器将会消耗完系统中所有可用的内存，造成系统崩溃。

【垃圾回收的两种方法】
1.标记清除（常用）
-？变量进入执行环境时，就标记这个变量为“进入环境”。当变量离开环境时，则将其标记为“离开环境”。
 //从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。
-垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。
-而在此之后还有标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。 
-在合适的时候，垃圾收集器工作，销毁那些带标记的值，并回收他们所占用的内存空间。
实例：
var m = 0,n = 19    // 把 m,n,add() 标记为进入环境。
add(m, n)           // 把 a, b, c标记为进入环境。
console.log(n)      // a,b,c标记为离开环境，等待垃圾回收。
function add(a, b) {
  a++
  var c = a + b
  return c
}

2.引用计数（不常用）
-语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。
 如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。

注意：如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致【内存泄漏】

问题：循环引用导致无法被回收
function func() {
    let obj1 = {};
    let obj2 = {};

    obj1.a = obj2; // obj1 引用 obj2
    obj2.a = obj1; // obj2 引用 obj1
}
//当函数 func 执行结束后，返回值为 undefined，所以整个函数以及内部的变量都应该被回收
//但根据引用计数方法，obj1 和 obj2 的引用次数都不为 0，所以他们不会被回收。

要解决循环引用的问题，需要在不使用它们之后手工将它们设为空：
obj1 = null;
obj2 = null;

-----------------------------------会引起内存泄漏的情况-----------------------------------------------
//代码写法不当，会导致变量一直处于“进入环境”的状态，无法被回收

1.意外的全局变量
-在函数内生命变量不加var，会使该变量成为全局变量。在函数执行完毕之后该变量占用的内存不会被释放。
-全局调用函数，其中的this指向全局对象，在函数内部添加到this上的属性，在函数执行完毕时候也不会被清除。

解决办法：在JS文件头部加上"use strict"，启用严格模式解析js代码，避免意外的全局变量。

2.被遗忘的计时器或回调函数
将不再需要的计时器用clearTimeout/clearInterval清除
且定时器回调函数内部引用的变量也不会被释放（data）
var data = getData();
setInterval(function(){
    console.log(data);
},1000)

3.被遗忘的事件处理函数
假设我们为某dom元素使用addEventListener/onclick添加了事件处理函数
之后不再使用该DOM元素了，就将其从DOM中移除了(removeChild/innerHTML覆盖).
记得在移除之前先注销事件处理函数(使用removeEventListener/node=null)，

4.闭包
闭包可以维持函数内局部变量，使其得不到释放。
function bindEvent(){
    //定义了一些局部变量
    obj.onclick = function(){
        //这里未用到外面定义的任何局部变量      //此处为闭包，该函数会保存外层函数的作用域。但是未用到外部的任何局部变量，这就是明显的浪费。
    }
}

解决办法：将事件处理函数定义在外部
function handleClick(){
    //。。。
}
function bindEvent(){
    //定义了一些局部变量
    obj.onclick = handleClick;
}

-------------------------------------内存泄漏的识别方法----------------------------------

使用Chrome开发者工具：
-打开开发者工具Performance
-勾选Screenshots和memory
-左上角小圆点开始录制(record)
-停止录制

图中 Heap 对应的部分就可以看到内存在周期性的回落也可以看到垃圾回收的周期,
如果垃圾回收之后的最低值(我们称为min),min在不断上涨,那么肯定是有较为严重的内存泄漏问题。

----------------------------------垃圾回收机制的使用场景优化---------------------------

1.数组array优化
const arr = [1,2,3,4]
//arr = []; 虽然让a变量变成了空数组，但在堆上重新申请了一个空数组对象
arr.length = 0;     //可以直接让数字清空，且数组类型不变

2.对象尽量复用
尤其在循环等出现的地方出现创建新对象，能复用就复用。不用的对象，尽可能设置为null，尽快被垃圾回收掉。
var t = {};     //只会创建一个新对象
for(var i=0; i<10; i++){
    //var t = {};       //每次循环都会创建一个新对象
    t.name = "yf";
    t.age = 22;
}
t = null;   //对象不用了就设置为null，等待垃圾回收

3.在循环中的函数表达式，能复用最好放到循环外面
for(var i=0; i<10; i++){
    //创建了10次函数对象
    var fn = function(param){
        //。。。
    }
    fn(i)
}
---
function fn(param){
    //。。。
}
for(var i=0; i<10; i++){
    fn(i)
}
fn = null;