# 1 五层协议栈模型补充

## 1.1【OSI 七层模型简述】

应用层 各种应用软件
表示层 数据格式标识，基本压缩加密功能
会话层 控制应用程序之间的会话，区分不同的进程
传输层(数据段) 负责将数组进行可靠或不可靠传递，建立端口到端口的通信
网络层(数据包) 定义 IP 地址，定义路由功能，建立主机到主机的通信
数据链路层(帧) 数据链路层将比特封装成数据帧并传递
物理层(比特 bit) 网络连接介质，如网线、光缆，数据在其中以比特位单位传输

----------------------------------------------------------HTTP 补充------------------------------------------------------

2.【http 响应报文-状态码补充】
400 Bad Request 错误请求，请求报文存在语法错误，可能是客户端传参错误
401 Unauthorized 未授权，表示发送的请求需要有认证信息，可能是客户端未登录
403 Forbidden 禁止，服务器拒绝请求，可能是客户端权限不足
404 Not Found 未找到，服务器找不到对应资源

500 服务器内部错误，服务器遇到错误，无法完成请求
501 服务器不支持当前请求所需要的某个功能
502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应
503 服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。

通用头部：Cache-Control、Connection、Transfer-Encoding
请求头部：Accept 相关首部、Authorication、If-Modified-Since、If-None-Math、Cookie、Referer、Range、Host、User-Agent
响应头部：Set-Cookie、Etag、Location
实体首部（补充请求报文或响应报文相关信息）：Content 相关首部、Expires、Last-Modified、Allow(资源正确的请求方式，如 GET/POST/HEAD)

---

3.【http 请求报文-GET 请求和 POST 请求区别】
https://segmentfault.com/a/1190000018129846

使用上： -可见性上：GET 请求参数放在 URL 上，POST 请求参数放在请求体里 -对数据长度的限制上：因为浏览器对 URL 有长度限制，故 GET 请求参数长度有限制；POST 请求参数长度可以非常大 -安全性上：POST 请求相较于 GET 请求安全一些。因为 GET 请求的参数在 URL 上是可见的，且 GET 请求能缓存&&参数会保存在浏览器历史中；POST 不能 -对数据类型的限制上：GET 只允许发送 ASCII 字符；POST 无数据类型的限制，也可以是二进制数据 -编码类型上：GET 为 application/x-www-form-urlencoded；POST 为 application/x-www-form-urlencoded 或 multipart/form-data，为二进制数据使用多重编码。
深入：
-GET 是幂等的，故常用于无副作用的操作(获取信息，例如搜索)；POST 是非幂等的，故常用于有副作用的操作(修改服务器上的数据，例如新增/删除)。
//幂等：在网络不好的环境中 或者 后退按钮/刷新按钮，GET 请求可能会重复尝试，造成重复操作数据的风险
GET 和 POST 报文上的区别： -没有实质区别(只是 HTTP 请求的两种方式，传输层都是基于 TCP 协议的)，只是请求行的请求方法不同而已。 -至于两者的参数应该放在哪儿：约定上，GET 参数应放在 url 中；POST 参数应放在 body 中。
但实际上 POST 也可以在 url 上附带参数，GET 参数也可以写在 body 中，当然这需要服务端支持。

【GET 方法参数写法是固定的吗？】
约定中，参数是写在?后面，键值之间用=连接，键值对之间用&连接
但是实际上，我们也可以自己约定参数的写法，只要服务器能够解释出来即可
例如比较流行的写法是：http://www.example.com/user/name/yf/age/22

【POST 方法比 GET 安全？】
其实都是不安全的，因为 HTTP 在网络上是明文传输的，只要在网络节点上抓包，就能获取完整的报文
要想安全传输，只有加密，即 HTTPS

【GET 方法的长度限制？】
其实 HTTP 协议并未规定 url 和 body 的长度限制，对 url 的限制大多是浏览器和服务器的原因。
服务器因为处理长 url 要消耗较多资源，且为了防止恶意构造长 url 来攻击，会给 url 长度加限制。

【POST 方法会产生两个 TCP 数据包？】
有些文章提到：post 会将 header 和 body 分开发送，先发送 header，服务端返回 100 状态码再发送 body。
但是 HTTP 协议并未说明 POST 会产生两个 TCP 数据包，实际上将 header 和 body 分开发送只是部分浏览器或框架的请求行为，不属于 post 必然行为。

---

4.【http 报文-头部补充】
//通用头部
Cache-Control 控制缓存
Connection 是否需要持久连接（HTTP1.1 默认持久连接） keep-alive / close
Transfer-Encoding 报文主题的传输编码格式 chunked(分块) / identity(未压缩和修改) / gzip(LZ77 压缩) / compress(LZW 压缩,弃用) / deflate(zlib 结构压缩)

//请求头
Accept 告知(服务器)客户端可以处理的内容类型  
If-Modified-Since  
If-Unmodified-Since 。。。可用于断点续传？
If-None-Match
If-Match 。。。可用于断点续传？
Range 告知服务器返回文件的哪一部分, 用于断点续传？
Host 指明了服务器的域名（对于虚拟主机来说），以及（可选的）服务器监听的 TCP 端口号
User-Agent 告诉 HTTP 服务器， 客户端使用的操作系统和浏览器的名称和版本

//响应头
Location 需要将页面重新定向至的地址。一般在响应码为 3xx 的响应中才会有意义
ETag 资源特定的标识符

//实体头（针对请求报文和响应报文的实体部分使用首部？）
Allow 资源可支持 http 请求的方法
Last-Modified 资源最后的修改时间
Expires 响应过期时间

---

5.【http 报文-协议版本补充】

【HTTP1.0】
串行连接：每次请求都打开一个新的 TCP 链接，收到响应之后立即断开连接。

【HTTP1.1】 -默认使用长连接(/持久连接)：即在一个 TCP 连接上可进行多次 http 请求和响应 -添加了一些请求头和响应头：实现缓存控制(Etag/If-Modified-Since/If-None-Match/If-unmodified-since/If-Match)、允许范围请求 Range。
-Host 头部：HTTP/1.1 的请求消息和响应消息都必须包含 Host 头部，以区分同一个物理主机中的不同虚拟主机的域名

缺点：线头阻塞
下次请求必须等到上次响应返回后才能发起，如果上次的请求还没返回响应内容，下次请求就只能等着

---

【HTTP2.0】
服务端推送： 服务端能主动把资源推送给客户端，指把客户端所需要
的 css/js/img 资源伴随着 index.html 一起发送到客户端，省去了客户端再请求这些资源。
header 压缩：HTTP/2.0 使用 encoder 来减少需要传输的头部大小，并且通讯双方各自缓存一份头部 fields 表。既避免了重复头部的传输，又减小了需要传输的大小。
新的二进制格式： HTTP/2 采用二进制格式传输数据，相比于 HTTP/1.1 的文本格式，二进制格式具有更好的解析性和拓展性
多路复用：HTTP/1.1 持久连接的升级版。 -在一个 TCP 连接中即允许并发的发起多个请求，每个请求及请求的响应不需要等待其他的请求或响应。
这样某个任务耗时严重，不会影响到其他连接的正常执行（即避免了阻塞问题）
-HTTP/2 引入了一个二进制分帧层，客户端和服务端进行传输时，数据会先经过二进制分帧层处理，转化为一个个带有请求 ID 的帧，以流的形式传输。 -服务端收到之后，根据帧中的标识。知道该帧属于即请求，通过重新排序还原请求。

【多路复用解决的问题】（就是 HTTP/1.1 存在的问题）
1.TCP 慢启动： TCP 连接建立后，会经历一个先慢后快的发送过程，如果我们的网页文件(HTML/JS/CSS/icon)都经过一次慢启动，对性能是不小的损耗。
另外慢启动是 TCP 为了减少网络拥塞的一种策略，我们是没有办法改变的。 2.多条 TCP 连接竞争带宽： 如果同时建立多条 TCP 连接，当带宽不足时就会竞争带宽，影响关键资源的下载。
3.HTTP/1.1 队头阻塞： 尽管 HTTP/1.1 长链接可以通过一个 TCP 连接传输多个请求，但同一时刻只能处理一个请求，当前请求未结束前，其他请求只能处于阻塞状态。

---

【HTTP3.0】
HTTP2 的缺点来自于 TCP 协议本身：是可靠连接，如果出错则整个连接都要等待重传；
HTTP1.1 可以同时使用 6 个 TCP 连接，一个阻塞另外五个还能工作，但 HTTP/2 只有一个 TCP 连接，阻塞的问题便被放大了。
所以 HTTP3 在 UDP 协议的基础上实现多路复用、TLS 加密、流量控制、出错重传
//Google 实现了一个基于 UDP 协议的 QUIC 协议，并使用在了 HTTP/3 上

HTTP3.0 部分功能： 1.避免包阻塞
在基于 UDP 的 QUIC 协议中，不同流之间的数据传输真正实现了相互独立互不干扰，某个流的数据包在出问题需要重传时，并不会对其他流的数据报传输产生影响 2.快速重启会话
普通基于 tcp 的连接，是基于两端的 ip 和端口和协议来建立的。在网络切换场景，例如手机端切换了无线网，使用 4G 网络，会改变本身的 ip，这就导致 tcp 连接必须重新创建。
而 QUIC 协议使用特有的 UUID 来标记每一次连接，在网络环境发生变化的时候，只要 UUID 不变，就能不需要握手，继续传输数据。

---

【HTTP 和 HTTPS 的区别】（HTTPS 是传输层的协议，HTTP 是应用层的协议？）
-HTTPS 使用 443 端口，而 HTTP 使用 80
-HTTP 是超文本传输协议，是明文传输；HTTPS 是经过 SSL 加密的协议，传输更安全
-HTTPS 需要申请证书，且 HTTPS 比 HTTP 慢，因为 HTTPS 除了 TCP 握手的三个包，还要加上 SSL 握手的九个包

---

【HTTPS 是如何进行加密的？】(https=http+SSL/TLS)

浏览器在发送消息给服务器之前，先向服务器请求其公钥

/服务器 -服务器拿着其公钥以及企业、网站等各种信息，到 CA(第三方认证中心)
-CA 会通过一种单向 hash 算法(比如 MD5)，生成数字证书（这些信息的唯一标识，一旦构成数字签名的信息发生变化，hash 值就会改变）
-CA 还会使用自己的私钥对数字证书进行加密（以前 CA 是用私钥对服务器的公钥进行加密）

//浏览器 -浏览器拿到之后，使用浏览器本地内置的 CA 公钥解开数字证书并验证，从而拿到正确的公钥。
-(由于非对称加密性能低下)，拿到公钥以后，客户端会随机生成一个对称密钥。使用公钥加密此对称密钥发送给服务端，服务端用自己的私钥解开对称密钥。 -之后的加密连接就通过该对称密钥来进行对称加密。

----------------------------------------------------下面是有关加密的内容（了解即可）----------------------------------------------

对称加密：客户端和服务端公用一个密钥来对消息加解密。 -先将消息用密钥加密，然后将加密后的内容和密钥一起传给对方。
缺点：密钥在传输过程中可能被截获，传输内容就会暴露。

非对称密钥：客户端和服务端均拥有一个公钥和私钥，公钥加密的内容只有对应私钥才能接密。 -客户端在向服务器发送消息之前，先向服务器请求公钥；服务器返回公钥给客户端 -客户端用该公钥加密消息，发送给服务器。服务器收到之后用其私钥进行解密，即得到内容。
缺点：攻击者可能在服务器返回公钥时截获公钥，替换为攻击者自己的公钥。当客户端用这个公钥加密消息发送给服务器时，攻击者截获它，进行解密得到内容。

非堆成密钥的缺点：客户端不知道公钥是由服务端返回的，还是攻击者返回的。

方法一：使用第三方认证（因此再引入一个第三方使用私钥加密我们自己的公钥）
//浏览器已经内置一些权威第三方认证机构的公钥 -客户端在向服务器发送消息之前，先向服务器请求公钥；服务器用【第三方私钥】加密我们的公钥，再发给客户端 -客户端会使用【第三方公钥】来解开【通过第三方私钥加密过的 我们自己的公钥】。 -客户端用该公钥加密消息，发送给服务器。服务器收到之后用其私钥进行解密，即得到内容。
缺点：第三方认证是面向所有人的，中间人也能够申请证书。

方法二：数字签名
//服务器 -服务器拿着其公钥以及企业、网站等各种信息，到 CA(第三方认证中心)
-CA 会通过一种单向 hash 算法(比如 MD5)，生成数字证书（这些信息的唯一标识，一旦构成数字签名的信息发生变化，hash 值就会改变）
-CA 还会使用自己的私钥对数字证书进行加密（以前 CA 是用私钥对服务器的公钥进行加密）

//浏览器 -浏览器拿到之后，使用浏览器本地内置的 CA 公钥解开数字证书并验证，从而拿到正确的公钥。
-(由于非对称加密性能低下)，拿到公钥以后，客户端会随机生成一个对称密钥。使用公钥加密此对称密钥发送给服务端，服务端用自己的私钥解开对称密钥。 -之后的加密连接就通过该对称密钥来进行对称加密。

总结：HTTPS 的工作方式 -在验证阶段使用非对称加密+第三方认证+数字签名，以保证浏览器获取正确的公钥 -获取到正确的公钥后使用对称加密进行通信。
