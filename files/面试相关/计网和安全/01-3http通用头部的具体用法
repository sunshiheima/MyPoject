写的很好，且这6个部分都有服务端的实现代码
https://juejin.im/post/6844903661596835854

---------------------------------------------------

初级操作：（只需要配置header即可实现）
-多语言(请求头Accept-Language)
-防盗链(请求头Referer && Referered)
-省流量gzip(请求头Accept-Encoding、响应头Content-Encoding)

1.多语言（智能返回用户所需的语言，使得网站可进行多种语言的切换）
//客户端
Accpet-Language: zh,en-US;q=0.9,en;q=0.8
//服务端
处理请求头当中的Accept-Language，将其变成带权重q的数组。排序好之后：[{"name":"zh","q":1},{"name":"en-US","q":0.9},{"name":"en","q":0.8}]
服务端在自己拥有的语言中，选择权重值最高的那个返回给客户端，若没有上述三种语言就给官方(默认)语言

2.防盗链（常用于对图片的限制，只有本域名可以获取到，其他域名无法获取到）
//客户端
在某网站上请求一张图片，请求头中会自动带上Referer字段，表示当前网站的域名
//服务端
通过Rederer和Referered?发现此网站域名不在我方白名单内，不将此图片提供给网站
没有来源就直接放行（别人可能在单独打开这张图片的）

3.gzip（传输压缩的网页）
//客户端
Accept-Encoding: gzip, deflate, br
//服务端
根据该请求头字段值，开始配置压缩，并设置响应头Content-Encoding，按照服务器优先支持的匹配。
服务器压缩网页并返回给客户端

---------------------------------------------------

中级操作：（不仅需要配置header，还需要客户端和服务端配合）
-客户端给服务器发送内容(请求头Content-Type && Content-Length)
-客户端从服务器获取内容(请求头Range、响应头Content-Range) —— 断点续传
-客户端爬虫，抓取网页

1.客户端给服务器发送内容
//客户端
告知待发送内容的类型和长度，即设置请求头Content-Type和Content-Length
请求体中放内容
//服务端
监听到数据是一组Buffer，接收数据完毕后合并Buffer
然后根据Content-Type对数据进行格式化处理（Content-Type不同，格式化处理方法也不同）

2.客户端从服务端获取内容
//客户端
在请求头中表明自己想要的资源的哪部分内容，即设置请求头Range（例如Range: bytes 0-3）
//服务端
“请接收，此文件一共8字节，现在将前3字节给你” - Content-Range: bytes 0-3/7
//客户端
“把接下来的给我” - Range: bytes=4-7
//服务端
Content-Range: bytes 4-7/7 ？

//使用range获取，就是【断点续传】的简易版
//注意：文件字节的位置是从0开始的，所以range的全范围是0~size-1/size-1

3.客户端爬虫，抓取网页
操作：只要建一个请求获取到网页即可
难点：如何从网页中将有效信息剥离出来

//其中：资源不可能一次下载完成，因此每次获取到数据都要push到arr中（而我们数据的形式就是Buffer，即二进制数据）
//也是利用Content-Range?









