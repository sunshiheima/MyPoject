vue和React的区别：

1.监听数据变化的实现原理不同
1) Vue通过getter/setter以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能。
2) React默认是通过比较引用的方式进行的，如果不优化(例如【使组件继承PureComponnet】或者【使用shouldComponentUpdate生命周期函数】)，就可能导致虚拟DOM不必要的对比过程和新渲染。
   (注：pureComponent是React提供的API，将对props和state进行浅层比较。 写法：import React, {PureComponnet} from 'react'; class App extends PureComponent {}  )

vue精确监听数据变化，而React不精确的监听数据变化。是因为两者的设计理念不同。vue使用的是可变数据，而React更强调数据的不可变。vue更加简单，而React构建大型应用大时候的鲁棒性更好，也就是更加健壮、应对危险的能力更强一些！

管理数据一般都会用到专门的数据管理框架，比如vuex和redux。


2.数据流的不同
1)vue中默认实现双向绑定：在父子组件之间，通过props可以双向绑定；组件与DOM之间可以通过v-model双向绑定。
  在vue2当中发生了改变，也就是父子组件之间不能双向绑定了（但是提供了一个语法糖自动帮你通过实践的方式修改），并且vue2已经不鼓励组件对自己的props进行修改了
2)而React从诞生之初就不支持双向绑定，React一直提倡的是单向数据流。

但是，很多时候我们都是用vuex或者redux这样的数据管理框架，它们实现的都是单向数据流，因此很多时候我们感受不到这一点的区别。

3.HOC和mixins
1)在vue中我们组合不同功能的方式是通过mixin
2)而在React当中我们通过HOC(高阶组件)
原来React也是使用mixin的，但是后来觉得这对组件侵入太强会导致很多问题，就启用mixin转而使用HOC了。

问：vue当中为什么不采用HOC的方式来实现了？
答：高阶组件本质就是高阶函数，React的组件是一个纯粹的函数，所以高阶函数在React当中实现起来较为简单。
但是vue就不行了，因为vue组件本身是一个被包装的函数（这个包装的过程就是vue帮我们默默做的一些事情，是为了让我们使用起来更加方便），如果我们自己把组件的组件俺的声明包装以下，返回一个高阶组件，那么这个被包装的组件就无法正常工作了。

4.组件通信的区别
1)在vue当中有三种方式可以实现组件通信：
  1.父组件通过props向子组件传递数据
  2.子组件通过事件event向父组件发送消息（也可以让父组件传递给子组件回调函数，子组件调用，将要传递给父组件的数据作为该函数的参数）
  3.v2.2版本中新增的provide/inject来实现父组件向子组件注入数据，可以跨越多个层级。
  4.还有一些访问$parent/$children等比较dirty的方式就不说了
2)在react当中也有三种方式：
  1.父组件通过props可以向子组件传递数据
  2.父组件通过给子组件添加函数类型的props，让子组件调用该函数，并将需要传递的数据作为该函数的参数，即可实现子组件将数据传递给父组件！
  3.React当中可以通过/context进行跨层通信，这个和vue提供的provide/inject起到的作用差不多！

vue中子组件向父组件传递消息由两种方式：事件和回调函数，而且vue是更倾向于使用事件的。
但是React本身并不支持回调函数，这是它们二者最大的区别。


5.模板渲染方式的不同
1) 在表层上，模板的语法不同。vue是通过一种扩展的HTML语法进行渲染的。React是通过JSX渲染模板来进行渲染的（但实际上React并不依赖JSX）。
2) 在深层上，模板的原理不同。。。

6.vuex和redux的区别
1)Redux 使用的是不可变数据，而Vuex的数据是可变的。Redux每次都是用新的state替换旧的state，而Vuex是直接修改
2)redux在检测数据变化的时候，是通过diff的方式比较差异的，而vuex其实和vue的原理一样，是通过getter/setter来比较的（其实它内部直接是创建了一个vue实例用来跟踪数据变化的）


总结：
其实归根到底，就是vue和react实际理念上的区别。
React更倾向于构建稳定大型的应用；而vue则更倾向于简单迅速的解决问题，更灵活，不用严格遵循条条框框。
因此也会给人一种大型项目用React，小型项目用vue的感觉！