HTTP缓存的定义：
HTTP缓存其实就是浏览器保存通过http获取的所有资源，是浏览器将网络资源存储在本地的一种行为

----------------------------------------------------------------

(服务端)HTTP缓存决策：(即客户端第一次请求资源，服务端返回该资源时决策的！)
//根据我们的资源是否可复用
-当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store，拒绝一切形式的缓存；
-若可复用，则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设置 Cache-Control 的值为 no-cache；
-若不需要，则考虑该资源是否可以被代理服务器缓存，根据其结果决定Cache-control设置为 private 还是 public；
-然后考虑该资源的过期时间，设置Cache-control的 max-age 和 s-maxage 值；
-最后，配置协商缓存需要用到的 If-Modified-Since 、If-None-Match 等参数

-----------------------------------------------------------------
文章很好，但是下面自己总结的更好！
https://juejin.im/post/6855469171703185416
建议将下面笔记和这篇文章一起食用！（内含node服务端代码）
https://juejin.im/post/6844903736196726798#heading-5

(客户端)HTTP缓存决策：(即客户端再一次请求资源)

详述：
1.看看是否命中强缓存，如果命中，就直接使用缓存了。
2.如果没有命中强缓存，就发请求到服务器检查看是否命中协商缓存。
3.如果命中协商缓存，服务器会返回304将资源重定向到浏览器本地缓存。
  //如果服务端提示缓存资源未改动（Not Modified），资源会被【重定向】到浏览器缓存，这种情况下网络请求对应的状态码是 304
4.否则，返回最新的资源。

--------

1.强缓存
浏览器在加载资源时，会先根据【本地缓存资源的header】中的【信息】来判断是否命中【强缓存】。如果命中则直接使用缓存中的资源不会再向服务器发送请求。
-本地缓存资源header：即上一次访问该资源，服务器返回该资源时的【响应header】，
-信息：expires && cache-Control。是之前服务端配置的，用于看缓存是否过期。
  -【Expires】: http1.0规范，代表资源的失效时间（绝对时间。当更改了客户端时间，使服务器与客户端时间偏差较大时，就会导致缓存混乱）
  -【Cache-control: max-age = XX(秒)】：http1.1规范，代表资源的有效时间（相对时间）

优先级：
Cache-control的优先级更高（Cache-control是Expires的完全替代方案，Expires出现的唯一目的就是向下兼容而已！）

补cache-control还有其他可选值：
-s-maxage=xxx秒：优先级高于max-age，表示若超过有效期，则向代理服务器请求其缓存内容。 //s-maxage仅在代理服务器中生效，客户端中我们只考虑max-age
-no-cache：每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期(即直接跳过强缓存，去看是否命中协商缓存)
-no-store：禁止使用缓存，每一次都要重新请求数据
-public：可以被所有的用户缓存，包括终端用户和 CDN 等中间代理服务器
-private：(默认值)只能被终端用户的浏览器缓存，不允许 CDN 等中继缓存服务器对其缓存

--------

2.协商缓存
当强缓存没有命中时，浏览器会发送一个请求到服务器，服务器根据【该请求header】中的【信息】来判断是否命中【协商 缓存】。如果命中，则返回304，告诉浏览器资源未更新，可使用本地的缓存。
1) Last-Modified/If-Modified-Since
Lsat-Modify: 浏览器第一次请求该资源时，服务器的响应header中会加上Last-Modify，代表该资源最后被修改的时间。
If-Modify-Since：当浏览器再次请求该资源时，请求头中会加上If-Modify-Since，该值为上一次响应header中的Last-Modify值。
服务器收到之后，根据资源的最后修改时间，判断资源是否被修改。
若未被修改，则返回304，并且不会返回资源内容和Last-Modify的值。
若修改了，服务器返回最新资源并设置新的Last-Modified && 将其存入缓存(内存或硬盘)

缺点（因此便有了ETag）
-存在周期性重写某些资源，但资源实际包含的内容并无变化；
-被修改的信息并不重要，如注释等；
-Last-Modified无法精确到毫秒，但有些资源更新频率有时会小于一秒。

2) ETag/If-None-Match
ETag: 浏览器第一次请求该资源时，服务器的响应header中会加上ETag，代表该资源的唯一标识。
If-None-Match：当浏览器再次请求该资源时，请求头中会加上If-None-Match，该值为上一次响应header中的ETag值。
服务器收到之后，根据资源的唯一标识，判断资源是否被修改。
若未被修改，则返回304，由于ETag无论有无变化都会重新生成，所以会同时返回ETag
若修改了，服务器返回最新资源并设置新的ETag && 将其存入缓存(内存或硬盘)
//注意：ETag是基于文件内容进行编码的，可以保证每一个资源是唯一的，资源变化都会导致Etag变化。

ETag解决了Last-Modified使用时可能出现的：（但Etag只能作为Last-Modified的补充和强化，而非替代）
-资源的内容没变但时间戳变了的问题
-在一秒钟以内资源变化但Last-Modified没变的问题

优先级：
服务器会先验证If-None-Match（即上一次服务器返回给客户端的ETag），一致的情况下。
才会继续比对If-Modified-Since（即上一次服务器返回给客户端的Last-Modified），最后才决定是否返回304。

