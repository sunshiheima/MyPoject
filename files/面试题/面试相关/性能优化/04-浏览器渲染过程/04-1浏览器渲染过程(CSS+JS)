【浏览器内核】

浏览器内核分为两部分：【渲染引擎】和【JS引擎】
//因为JS引擎越来越独立，内核成了渲染引擎的代称

浏览器内核分为四种：Trident(IE)、Gecko(Firefox)、Blink(Chrome/opera)、Webkit(Safari)
//注意Chrome内核已经不再是Webkit，而是Blink了。但是Blink实则也是基于Webkit衍生的一个分支

渲染引擎：包括HTML解释器、CSS解释器、布局、网络、存储、图形音视频图片解码器 等等。

补充【浏览器当中的线程】
GUI渲染线程、JS引擎线程、定时器触发线程(setTimeout)、浏览器事件线程(onclick)、http异步线程、EventLoop轮询处理线程
其中常驻线程有：GUI渲染线程、JS引擎线程、浏览器事件线程(onclick)
其中GUI渲染线程和JS引擎线程互斥

--------------------------------------

【浏览器初次渲染过程】
实则就是: HTML/CSS/JS资源 ---> (经过浏览器内核内部各种【功能模块】) ---> 图像

浏览器内核内部正是这些功能模块互相配合协同工作的，渲染过程及对应的功能模块有：
-解析HTML(HTML解释器)：将HTML文档经过词法分析输出DOM树，在解析HTML的过程中发出了页面渲染所需的各种外部资源请求。
-计算样式(CSS解释器)：解析CSS文档，生成样式规则，此过程和解析HTML是并行的。
 //然后浏览器将识别并加载所有CSS样式信息，将其与DOM树合并，最终生成render树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）
-计算图层布局(图层布局计算模块)：布局计算每个对象的精确位置和大小，生成布局渲染树。
-绘制图层(视图绘制模块)：浏览器会根据我们的DOM代码结果，把每一个页面图层转换为像素，将像素渲染到屏幕上，在这个过程中会对所有的媒体文件进行解码。
 //然后浏览器会合并各个图层，将数据由CPU输出给GPU最终绘制在屏幕上
 （复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了【优化动画性能】，我们有时会手动区分不同的图层）
-(JavaScript引擎模块)：编译+执行Javascript代码


简单版：
DOM树：解析HTML文档，转换文档中的标签到DOM节点，生成DOM树
CSSOM树：同时(并行)解析CSS(外部CSS文件/样式元素)，生成CSSOM树
渲染树：将DOM树和CSSOM树结合，生成渲染树(Render Tree)
布局渲染树：从根节点递归调用，计算每一个元素的大小和位置，给每个节点所应该出现在屏幕上的精确坐标。便得到了基于渲染树的布局渲染树。
绘制渲染树：遍历渲染树，每个节点将使用UI后端层来绘制。

--------------------------------------

【后续有新元素加入到DOM树当中时】
浏览器会通过CSS引擎【遍历查询!】CSS样式表，找到符合该元素的样式规则应用到此元素上，然后再重新去绘制它。

1.【CSS写法优化】
注意！！！CSS引擎查找样式表，是从右到左匹配的。

好的【CSS选择器书写】习惯：
-避免使用通配符，只对需要用到的元素进行选择。（使用通配符会去遍历每一个元素）
-关注可以通过继承实现的属性，避免重复匹配重复定义？
-少用标签选择器。尽量用类选择器替代。
-id和class选择器前不应该有多余的标签选择器。
-减少嵌套(不要超过三层)，后代选择器的开销是最高的。

2.【CSS资源加载优化】
注意：DOM和CSSOM合力才能构建渲染树。即浏览器在构建CSSOM的过程中，即便DOM已经解析完毕了，也不会渲染任何内容。
之后当CSSOM树构建完毕之后，才会开始在页面中渲染出内容！

解析HTML时，只有当解析到link标签或者style标签时，才会开始CSSOM的构建
因此应该让CSS尽早【将CSS放在head标签里】和尽快【启动CDN提高静态资源加载速度】的下载到客户端。

--------------------------------------

就算没有JS，DOM和CSSOM照样可以组成渲染树，页面依然会呈现 —— 纯静态，毫无交互。

JS阻塞渲染的过程
JS引擎是独立与渲染引擎而存在的，当HTML解析器遇到一个script标签时，它会暂停渲染过程，将控制权交给JS引擎。
JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。
等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。 
//其实就是JS引擎抢走了渲染引擎的控制权！

设计【JS阻塞渲染】的本质原因：
JS的作用在于修改：修改内容、样式、如何响应用户相互，本质上都是对DOM和CSSOM进行修改。
因为浏览器不知道JS会做什么改变，担心如果不阻止后续的操作，会造成混乱
因此设计为，让JS的执行阻止CSSOM && 在不作显式声明的情况下，JS的执行也会阻塞DOM.

但是作为开发者，我们知道JS之后会做什么改变，
如果我们确认一个JS文件不需要立即执行，我们可以使用defer/async来避免不必要的阻塞。

1.【JS加载优化】
-正常模式下：JS会阻塞浏览器，浏览器必须等待js文件【加载】和【执行完毕】才能去做其他事情。
-async模式下：它的加载是异步的，不会阻塞渲染；当它加载结束，阻塞渲染并执行JS脚本。
 //适用于，当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时
-defer模式下：它的加载是异步的，不会阻塞渲染；当它加载结束，也不会阻塞渲染执行JS；等整个文档解析完成、DOMContentLoaded 事件即将被触发时，标记了defer属性的JS脚本才会【依次】执行!
 //适用于，当脚本依赖于 DOM 元素和其它脚本的执行结果时

 