【原型模式】
当我们想要创建一个对象时，会先找到一个对象作为原型，然后通过【克隆原型】的方式来创建出一个与原型一样（共享一套数据/方法）的对象
Object.create()方法就是原型模式的天然实现；
准确的说，只要我们还在借助Prototype来实现对象创建和原型继承，那么我们就是在应用原型模式

注意：
在JS中，我们使用原型模式，并不是为了得到一个副本，而是为了得到与构造函数（类）相对应的类型的实例、实现数据/方法的共享。
克隆是实现这个目的的方法，但克隆本身并不是我们的目的。

谈原型模式，其实是谈原型范式（关键就是原型、原型链）

一些面试官可能会刻意混淆 JavaScript 中原型范式和强类型语言中原型模式的区别，当他们这么做的时候不一定是因为对语言、对设计模式的理解有问题。
而很有可能是为了考察你对象的深拷贝。

【对象的深拷贝】的其他问法：【模拟JAVA中的克隆接口】、【JavaScript实现原型模式】

---------------------------------------------------------------------------------------------

下面就是递归实现深拷贝的核心思路（重点掌握！）
-调用深拷贝方法，若属性为值类型，则直接返回；若属性为引用类型，则递归遍历。
function deepClone(obj) {
    // 如果是 值类型 或 null，则直接return
    if(typeof obj !== 'object' || obj === null) {
        return obj
    }
    
    // 定义结果对象
    let copy = {}
    
    // 如果对象是数组，则定义结果数组
    if(obj.constructor === Array) {
        copy = []
    }
    
    // 遍历对象的key
    for(let key in obj) {
        // 如果key是对象的自有属性
        if(obj.hasOwnProperty(key)) {
            // 递归调用深拷贝方法
            copy[key] = deepClone(obj[key])
        }
    }
    
    return copy
} 


