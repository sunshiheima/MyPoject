观察者模式：

【定义】
定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。

【定义解读】
-(一个)发布者：当目标状态的对象发生变化时，会通知所有观察者对象
-(多个)订阅者/观察者：得到发布者的通知后就自动更新。

【套路】
-划分角色(为发布者和订阅者)
-监听状态变化
-发布者通知到订阅者

【示例1】
产品经理拉群组织程序员，当拿到需求文档之后，通知程序员干活。

【示例2】
Vue数据双向绑定(响应式系统)的实现原理

书中的概念（我感觉比较模糊，不用在意）
在Vue中，当我们修改状态时，视图会随之更新，这就是Vue的数据双向绑定（又称响应式原理）
-在Vue中，每个组件实例都有相应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖
-之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新

个人的理解（重!）
在Vue数据双向绑定的实现逻辑里(见书中图)，有这样五个角色（前三个是关键）：
-observer: 相当于发布者publisher，当目标对象的状态发生变化时(数据监听器)，会通知所有观察者对象。
 //具体就是-为target的每一个属性都装上监听器(以监听状态变化)，一旦状态发生变化就通知所有订阅者Dep
 //Object.keys(target).forEach((key) => {...})
 //Object.defineProperty(target, key, {get: xxx, set: 通知所有订阅者Dep})
-Dep: 分担了之前发布者publisher的一部分工作（增加订阅者和通知订阅者）
-watcher: 相当于订阅者/观察者observer，得到发布者的通知后就自动更新视图。
-view：视图
//-compile: MVVM 框架特有的角色，负责对每个节点元素指令进行扫描和解析。也负责指令的数据初始化、订阅者的创建这些“杂活”


-----------------------------------------------------------------------------------------------
发布-订阅模式：

【发布-订阅模式和观察者模式的区别】（是否存在第三方）
观察者模式：发布者直接触及订阅者
发布-订阅模式：发布者不直接触及到订阅者，而是由第三方来完成实际通信的操作

【示例】
全局事件总线(Event Bus/Event Emitter)的实现，这个全局事件总线即发布订阅模式中的第三方！
//Event Bus在Vue、Flutter等前端框架中有，Event Emitter在Node中有

在Vue中，有时候 A 组件和 B 组件中间隔了很远，看似没什么关系，但我们希望它们之间能够通信。
这种情况下除了求助于 Vuex 之外，我们还可以通过 Event Bus 来实现我们的需求。

Vue的Event Bus的用法：
//1.创建一个 Event Bus（本质上也是 Vue 实例）并导出
const EventBus = new Vue()
export default EventBus
//2.在主文件里引入EventBus，并挂载到全局
import bus from 'EventBus的文件路径'
Vue.prototype.bus = bus
//3.某组件当中订阅事件（即往第三方EventBus/EventEmitter添加事件）
// 这里func指someEvent这个事件的监听函数
this.bus.$on('someEvent', func)
//4.另一个组件当中发布事件（即调用之前添加的事件回调函数）
// 这里params指someEvent这个事件被触发时回调函数接收的入参
this.bus.$emit('someEvent', params)

极其重要！！！实现一个Event Bus！！！




