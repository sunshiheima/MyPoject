

正则表达式只是一门工具，目的是为了字符串模式匹配，从而实现【搜索】和【替换】功能。
它是一种描述规则的表达式，其底层原理就是使用状态机的思想进行模式匹配。
https://regexper.com/ 可以很好的可视化正则表达式。

---------------------------------------------------

【正则表达式的基本组成元素 —— 字符和元字符】
字符：数字、英文字母
特殊字符：元字符，比如^表示非、|表示或

1.【单个字符】—— 一一对应即可
例如：想在'apple'这个单词里找到‘a'这个字符，就直接用/a/这个正则就可以了
注意：
    -若要匹配普通字符：不变即可
    -若要匹配特殊字符：则需先用转义字符"\"将其转义（让其失去其本来的含义，变为一个单纯的字符）
    //另：如果这个字符不是特殊字符，那么转义字符"\"将会让它拥有特殊的含义。比如【空格\s】、【换行符\n】

2.【多个字符中的一个】—— （需使用【集合区间】和【通配符】实现多个字符的匹配）
-集合区间：比如/[0-9]/能匹配所有的数字，/[a-z]/能匹配所有英文小写字母，/[A-Z]/能匹配所有英文大写字母
 //注意：上面[]内部的表示或
-集合区间的简写：\d为数字[0-9]、\D为非数字、\w为下划线在内的字符（数字或字母[A-Za-z0-9]）、\W表示非字符、\s为空白字符、\S表示非空白字符

------------------------------------------------------

【单个字符出现次数】
?：表示出现0次或1次(有或无)
   例如：如果你要匹配color和colour这两个单词，就需要同时保证u这个字符是否出现都能被匹配到，正则表达式应位：/colou?r/。
*：表示出现0次或多次
   //通常用来过滤某些可有可无的字符串
+：表示出现1次或多次
{x}：出现x次
{min,max}：出现min次到max次之间
{min, }：出现至少min次
{0, max}：出现至多max次

-------------------------------------------------------

【字符出现位置】
\b：单词边界
\B：非单词边界
^：字符串开头（不是一行的开头嘛？）
$：字符串结尾（不是一行的结尾嘛？）
m：多行模式（multiple of line）
i：忽略大小写（ignore）
g：全局模式（global）

--------------------------------------------------------

分组、递归引用（这部分需重点看！）

1.分组：()
2.回溯引用：\1，可以将()括起来的内容看作是一个整体，存储在\1这个变量当中，之后需要用到的地方直接写\1即可引用它。
3.$1、$2等引用要被替换的字符串
    例如：var str = 'abc abc 123';
         str.replace(/(ab)c/g,'$1g');
         // 得到结果 'abg abg 123'
4.向前查找。。。
5.后向查找。。。


--------------------------------------------------------

【逻辑处理】
默认的正则规则都是“与”
非：[^regex]和!     //注意^只有放在[]里才表示非，放在外面表示字符串开头
或：|               //(a|b)

子表达式匹配的非关系就要用到前面介绍的前向负查找子表达式(?!regex)或后向负查找子表达式(?<!regex)。