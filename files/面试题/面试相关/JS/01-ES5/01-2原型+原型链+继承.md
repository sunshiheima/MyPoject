以下内容总结自红宝书！

# 1.原型的概念：

我们创建的每个函数都有：

- 1. prototype(原型/显示原型)：

  - 1.1)constructor:指向构造函数本身
  - 1.2)**proto**(隐式原型):指向它构造函数的 prototype 对象
  - 1.3)XXX:当前函数/构造函数的属性方法

## 1.1 使用：

我们通常会把需要公用的方法放到原型上，把实例特有的属性放到构造函数中！

## 1.2 补充：

1).实例被创建出来之后，实例和构造函数就没有直接联系了。而实例和原型有直接联系，原型和构造函数也有联系
当获取实例的 constructor 时，其实实例中并没有 constructor 属性，
那么会从实例的原型中读取，正好原型中有该属性
2)._proto_，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于原型中
实际上，这个属性来自于 Object.prototype，与其说是一个属性，不如说是一个 getter/setter
当使用实例的*proto*时，可以理解成返回了 Object.getPrototypeOf(实例)

# 2. 原型链：

```text
prototype.__proto__=父级的prototype；
父级的prototype.__proto__=父级的父级prototype；
```

# 3.实例属性查找路径

当以读取模式访问一个实例属性时，首先会在实例中搜索该属性。
如果没有找到该属性，则会继续搜索实例的原型。
在通过原型链实现继承的情况下，搜索过程就得以沿着原型链继续向上。直到 Object.prototype。(Object.prototype._proto_ === null)
注：所有函数的默认原型都是 Object 的实例，因此默认原型都会包含一个内部指针，指向 Object.prototype.
这也正是所有自定义类型都会继承 toString()、valueOf()等默认方法的根本原因。

[!注意]几乎所有 JavaScript 中的对象都是位于原型链顶端的 Object 的实例，除了 Object.prototype
（当然，如果我们手动用 Object.create(null)创建一个没有任何原型的对象，那它也不是 Object 的实例）

------------------------------------------------下面仅供参考，可不看---------------------------------------------------------------------------

原型：
就是这几个关键词：构造函数、实例、原型(构造函数.prototype)。重点当然是它们之间的关系。 1.构造函数和实例的关系：实例 = new 构造函数(); //注意：构造函数中的 this 是指向实例的 2.构造函数和原型的关系：原型.constructor === 构造函数; 3.实例和原型的关系：实例._proto_ === 原型；Object.getPrototypeOf(实例) === 原型
高程的原型图很经典，其中要注意的是：
实例被创建出来之后，实例和构造函数就没有直接联系了，实例和原型有直接联系。
构造函数和原型之间唯一的联系就是：原型.constructor===构造函数

原型链：
相互关联的原型组成的链状结构就是原型链！
当读取实例的属性时，如果找不到，就会查找于对象关联的原型中的属性，如果还查不到，就去找原型中的原型，一直到最顶层为止。
原型链的最顶层是 Object.prototype，Object.prototype._proto_ === null

继承：
我们常说“每一个对象都会从原型继承属性”，实际上，继承这个说法并不准确。
引用《你不知道的 JavaScript》中的话，就是：
继承意味着复制操作，而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联
这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法更准确些！

补充： 1.当获取实例的 constructor 时，其实实例中并没有 constructor 属性，
当不能读取到 constructor 属性时，会从实例的原型中读取，正好原型中有该属性 2._proto_，绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于原型中
实际上，这个属性来自于 Object.prototype，与其说是一个属性，不如说是一个 getter/setter
当使用实例的*proto*时，可以理解成返回了 Object.getPrototypeOf(实例)
