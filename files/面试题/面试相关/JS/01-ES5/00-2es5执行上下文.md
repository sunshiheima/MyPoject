# 1.ES5 中的执行上下文

ES5 规范又对 ES3 中执行上下文的部分概念做了调整，最主要的调整，就是去除了 ES3 中变量对象和活动对象，以 词法环境组件（ LexicalEnvironment component） 和 变量环境组件（ VariableEnvironment component） 替代。所以 ES5 的执行上下文概念上表示大概如下：

```js
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

# 2.词法环境

ES6 官方 中的词法环境定义：

词法环境是一种规范类型，基于 ECMAScript 代码的词法嵌套结构来定义标识符和具体变量和函数的关联。一个词法环境由环境记录器和一个可能的引用外部词法环境的空值组成。

[简单来说] 词法环境 是一种持有[标识符——变量映射]的结构。这里的 标识符 指的是变量/函数的名字，而 变量映射是对实际对象（包含函数类型对象）或原始数据的引用。

[!注意]这块看不懂没关系，你可以把它理解为 ES3 中的 变量对象，因为它们本质上做的是类似的事情，这里只是先把官方给出的定义放上来。这块概念比较烦：词法环境还分为两种，然后内部有个环境记录器还分两种，，这些概念在后面会用列表的形式归纳整理出来详细说明。

# 3.ES5 中的变量环境

[变量环境]它也是一个[词法环境]，所以它有着词法环境的所有特性。

之所以在 ES5 的规范力要单独分出一个变量环境的概念是为 ES6 服务的： 在 ES6 中，词法环境组件和 变量环境 的一个不同就是前者被用来存储函数声明和变量（let 和 const）绑定，而后者只用来存储 var 变量绑定。

[!注意]在上下文创建阶段，引擎检查代码找出变量和函数声明，变量最初会设置为 undefined（var 情况下），或者未初始化（let 和 const 情况下）。这就是为什么你可以在声明之前访问 var 定义的变量（虽然是 undefined），但是在声明之前访问 let 和 const 的变量会得到一个引用错误。

# 4.ES5 执行上下文总结

对于 ES5 中的执行上下文，我们可以用下面这个列表来概括程序执行的整个过程：

- 1)程序启动，[全局上下文]被创建

  - 1.1)创建全局上下文的[词法环境]

    - 1.1.1)创建[对象环境记录器]，它用来定义出现在[全局上下文]中的变量和函数的关系（负责处理 let 和 const 定义的变量）
    - 1.1.2)创建 外部环境引用，值为 null

  - 1.2)创建全局上下文的[变量环境]

    - 1.2.1)创建[对象环境记录器]，它持有[变量声明语句]在执行上下文中创建的绑定关系（负责处理 var 定义的变量，初始值为 undefined 造成变量提升）
    - 1.2.2)创建[外部环境引用]，值为 null

  - 1.3)确定 this 值为全局对象（以浏览器为例，就是 window ）

- 2)函数被调用，[函数上下文]被创建

  - 2.1)创建函数上下文的[词法环境]

    - 2.1.1)创建[声明式环境记录器]，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 let 和 const 定义的变量）
    - 2.1.2)创建[外部环境引用]，值为全局对象，或者为父级词法环境（作用域）

  - 2.2)创建函数上下文的[变量环境]

    - 2.2.1)创建[声明式环境记录器]，存储变量、函数和参数，它包含了一个传递给函数的 arguments 对象（此对象存储索引和参数的映射）和传递给函数的参数的 length。（负责处理 var 定义的变量，初始值为 undefined 造成变量提升）
    - 2.2.2)创建[外部环境引用]，值为全局对象，或者为父级词法环境（作用域）

  - 2.3)确定 this 值

- 3)进入函数执行上下文的执行阶段：

  - 3.1)在上下文中运行/解释函数代码，并在代码逐行执行时分配变量值。

[!注意]关于 ES5 中执行上下文的变更，个人感觉就是变了个概念，本质和 ES3 差别并不大。至于变更的目的，应该是为了 ES6 中的 let 和 const 服务的。

# 5.执行上下文栈

当一段脚本运行起来的时候，可能会调用很多函数并产生很多函数执行上下文，那么问题来了，这些执行上下文该怎么管理呢？为了解决这个问题，javascript 引擎就创建了 “执行上下文栈” （Execution context stack 简称 ECS）来管理执行上下文。

顾名思义，执行上下文栈是栈结构的，因此遵循 LIFO（后进先出）的特性，代码执行期间创建的所有执行上下文，都会交给执行上下文栈进行管理。

当 JS 引擎开始解析脚本代码时，会首先创建一个[全局执行上下文]，压入栈底（这个全局执行上下文从创建一直到程序销毁，都会存在于栈的底部）。

每当引擎发现一处函数调用，就会创建一个新的[函数执行上下文]压入栈内，并将控制权交给该上下文，待函数执行完成后，即将该执行上下文从栈内弹出销毁，将控制权重新给到栈内上一个执行上下文。

# 6.递归和栈溢出

执行栈本身也是有容量限制的，当执行栈内部的执行上下文对象积压到一定程度如果继续积压，就会报 “栈溢出（stack overflow）” 的错误。栈溢出错误经常会发生在[递归]中。

[!注意]程序调用自身的编程技巧称为递归（recursion）。

## 6.1 尾递归优化

```js
// 尾调用正确示范1
function a(x) {
  return b(x);
}

// 尾调用正确示范2
// 尾调用不一定要写在函数的最后为止，只要保证执行时是最后一部操作就行了。
function c(x) {
  if (x > 0) {
    return d(x);
  }
  return e(x);
}
```

尾调用之所以与其他调用不同，就在于它的特殊的调用位置。尾调用由于是函数的最后一步操作，所以不需要保留外层函数的相关信息，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了，这样一来，运行尾递归函数时，执行栈永远只会新增一个上下文。

[!注意]尾递归优化这种东西，现在没有任何一个浏览器是支持的（据说 Safari 13 是支持的），babel 编译也不支持。那 nodejs 里的 V8 引擎呢？它做好了，但是不给你用。

理由呢，它也很有道理：

- 有可能由于开发者水平原因，自己写的尾递归是死循环，然后引擎层面它优化掉了，又不报错，就裂开。
- 堆栈信息会在优化的过程中丢失，开发者调试非常困难，就很烦。

# es3/es5 执行上下文总结

```text
1)当函数运行的时候，会生成一个叫做 “执行上下文” 的东西，也可以叫做执行环境，它用于保存函数运行时需要的一些信息。
2)所有的执行上下文都会被交给系统的 “执行上下文栈” 来管理，它是一个栈结构数据，全局上下文永远在该栈的最底部，每当一个函数执行生成了新的上下文，该上下文对象就会被压入栈，但是上下文栈有容量限制，如果超出容量就会栈溢出。
3)执行上下文内部存储了包括：变量对象、作用域链、this 指向 这些函数运行时的必须数据。
4)变量对象构建的过程中会触发变量和函数的声明提升。
5)函数内部代码执行时，会先访问本地的变量对象去尝试获取变量，找不到的话就会攀爬作用域链层层寻找，找到目标变量则返回，找不到则 undefined。
6)一个函数能够访问到的上层作用域，在函数创建的时候就已经被确定且保存在函数的 [[scope]] 属性里，和函数拿到哪里去执行没有关系。
7)一个函数调用时的 this 指向，取决于它的调用者，通常有以下几种方式可以改变函数的 this 值：对象调用、call、bind、apply。
```
