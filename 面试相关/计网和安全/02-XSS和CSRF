疑问：浏览器同源策略的限制??? CSRF原理和注意部分有必要再看一下。。。也涉及到网页内图片等其他域资源的加载问题。。。

原文章：https://juejin.im/entry/6844903638532358151
(文章整体来说挺不错的，但是一些表述不是很到位，以我下面的表述为准！)

关键字：
XSS攻击的原理(跨站脚本攻击)
预防XSS攻击：HttpOnly防止劫取Cookie、用户的输入检查、服务端的输出检查、CSP、(输入内容长度限制、输入内容限制)
CSRF攻击的原理(跨站请求伪造)
预防CSRF攻击：验证码、Referer Check、Token验证、SameSite属性。
点击劫持的原理
预防点击劫持：frame busting、X-Frame-Options

------------------------------XSS攻击的原理 && 预防措施--------------------------------

XSS攻击：想办法注入恶意脚本，并让浏览器执行该恶意脚本
//一般有三种，分别有不同原理和相应预防措施：
//下述“恶意脚本”可能是JS代码/HTML/Flash

----

1.反射型
//说法一
攻击者在网页中加入恶意链接/表单提交按钮，其href或action就是指向攻击者服务器的。
当用户点击它们的时候就会向
攻击者服务器发起请求，攻击者服务器在响应内容中放入恶意脚本(被script标签包含的JS代码)
//说法二（常见于通过URL传递参数的功能）
攻击者构造出特殊的URL，会请求网站服务器，参数中包含恶意代码
攻击者诱导用户点击带有恶意代码的URL，网站服务端将恶意代码从URL中取出，拼接在HTML中返回给浏览器
//后续
浏览器接收并执行响应内容，该恶意脚本可能是恶作剧脚本，也可能是一段获取Cookie的JS代码
劫持Cookie之后，就能够冒充用户身份访问服务器，进行CSRF攻击了。

【阻止更严重的后果 —— HttpOnly防止劫取Cookie】
即浏览器禁止页面中用JS方式访问带有HttpOnly属性的Cookie，从而防止Cookie劫持。
所以准确来说，HttpOnly并非阻止XSS攻击，而是能阻止XSS攻击后的Cookie劫持攻击

【预防措施 —— 对url的查询参数进行转义】
app.get("/welcome", function(req, res) => {
  res.send(`${encodeURIComponent(req.query.type)}`);  //对查询参数进行编码
})

----

2.基于DOM（原理：DOM中的内联事件监听器和链接跳转，都能把字符串作为代码运行）
攻击者在网页的输入框中输入恶意脚本，点击提交之后浏览器并不会向服务器发送请求。
客户端会直接构造一个a标签，并将输入框中的内容以【字符串拼接】的形式作为赋给href属性
这样当用户点击该a标签时，该恶意代码就会执行。

//重点在于上述【字符串拼接】！这就是导致攻击成功的根本原因！
-在使用.innerHTML/.outerHTML/.appendChild/document.write()等API时要特别小心，不要把不可信数据作为HTML插到页面上
-尽量使用.innerText/.textContent/.setAttribute()等

【预防措施 —— 输入检查】（即不要相信用户的任何输入。对于用户的任何输入要进行检查、过滤和转义）
//具体
-对于URL链接，例如a标签的href属性/图片的src属性，直接使用encodeURIComponent来转义
-对于非URL链接，一般是一些特殊字符，如<，>。那么可以这样编码：
function encodeHtml(str) {
    return str.replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
}
-建立可信任的字符和HTML标签白名单，对于不在白名单之列的字符或者标签进行过滤或编码。

另：
在一些前端框架(Vue)中，会有一份decodingMap，用于对用户输入所包含的特殊字符或标签进行编码或过滤，如 <，>，script，防止 XSS 攻击
//在 vuejs 中，如果输入带 script 标签的内容，会直接过滤掉
const decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n'
}

----

3.存储型
攻击者在网页的某输入框(文章/评论发布区/用户私信)内输入恶意脚本，当点击提交按钮发送给服务器之后，服务器将其存储起来。
之后当有用户访问该文章或评论时，服务器返回的内容实则为之前输入的恶意脚本。

【预防措施 —— 输出检查】
服务器的输出可能存在问题。一般除富文本的输出外，在变量输出到HTML页面时，可以使用编码或转义的方式来防御XSS攻击。
例如利用 sanitize-html 对输出内容进行有规则的过滤之后再输出到页面中。

//前端数据传递给服务器之前，先转义/过滤(防范不了抓包修改数据的情况)
//服务器接收到数据，在存储到数据库之前，进行转义/过滤
//前端接收到服务器传递过来的数据，在展示到页面前，先进行转义/过滤

----------------------------------------------------------------------

除了转义，还需要其他手段来防范XSS攻击：

1.【CSP】(Content Security Policy)
服务端设置响应头的Content-Security-Policy/在前端设置meta标签，来指定策略。
//例如：下面的配置只允许加载同域下的资源
-Content-Security-Policy: default-src 'self'
-<meta http-equiv="Content-Security-Policy" content="form-action 'self';">    //两种方式效果相同，只是meta无法使用report

2.输入内容长度限制、输入内容限制（对于部分输入，可以限定不能包含特殊字符或者仅能输入数字等）

----------------------------------------------------------------------

【XSS检测】
//作为大公司，都有专门的安全部分负责这个工作。

1.使用通用XSS攻击字串手动检测XSS漏洞
如：复杂不知道干嘛的一大堆莫名其妙的字符。。。
-能够检测到存在于 HTML 属性、HTML 文字内容、HTML 注释、跳转链接、内联 JavaScript 字符串、内联 CSS 样式表等多种上下文中的 XSS 漏洞
-也能检测 eval()、setTimeout()、setInterval()、Function()、innerHTML、document.write() 等 DOM 型 XSS 漏洞
-并且能绕过一些 XSS 过滤器

2.使用第三方工具扫描
。。。





---------------------------------------CSRF攻击原理及预防措施-----------------------------------

CRSF攻击：即攻击者借助用户Cookie骗取服务器的信任，并在用户毫不知情的情况下以用户名义，伪造请求发送给受攻击服务器。

原理：
攻击者篡改网页，比如添加一张图片，但将其src设置为“域名等于当前页面域名，参数表示删除服务器上的某条数据”
当刷新网页加载图片时，会发起请求，请求url即图片的src。因为和当前网页域名相同，所以在发起请求时会自动带上Cookie
服务器接收请求发现是合法用户的Cookie，故允许删除数据。

原理续：
https://blog.csdn.net/xiaoxinshuaiga/article/details/80766369
CSRF(跨站请求伪造)
//网站A为存在CSRF漏洞的网站、网站B为攻击者构建的恶意网站、用户C为网站A的合法用户。
//当我们在地址栏输出url，得到的页面实则时服务器返回的内容。所以网站A的域名实则为提供内容的服务器的域名。
-用户C打开浏览器，访问网站A，输入用户名和密码请求登录网站A
-在用户信息验证通过后，网站A产生Cookie信息并返回给浏览器，Cookie存储在网站A域名下。此时用户登录网站A成功，之后可以正常发送请求到网站A
-用户点击了网站A中的一个恶意弹框，访问了网站B
-网站B当中，对A站点发出一个请求（所以域名与网站A相同），这样就能自动携带该域名下的cookie了，成功伪造了用户C身份来进行恶意操作。（注意攻击者并没有获取到Cookie的）

------------------

注意：
在这个攻击过程中，攻击者借助受害者的Cookie骗取服务器的信任，但并不能拿到Cookie，也看不到Cookie的内容。
而对于服务器返回的结果，由于浏览器同源策略的限制???，攻击者也无法进行解析，得不到任何东西。
CRSF能做的就是【给服务器发送请求，以执行请求中所描述的命令，在服务器端直接改变数据的值。(而非窃取服务器数据)】

预防措施：
1.验证码
CSRF攻击往往是在用户不知情的情况下构造了网络请求。而验证码会强制用户必须与应用进行交互，才能完成最终请求。
但因为出于用户考虑，不能给网站所有的操作都加上验证码。所以验证码只能作为一种辅助手段。
//一般再转账、交易等重要操作，增加验证码

2.Referer Check
在HTTP请求头中有一个字段叫Referer，它记录了该HTTP请求的来源地址。
通过Referer Check，可以检查请求是否来自合法的"源"。
//Referer Check 不仅能防范 CSRF 攻击，另一个应用场景是 "防止图片盗链"。
//但是Referer本身是可以被更改的

3.添加token验证
CSRF伪造身份成功，是因为Cookie当中包含了用户的身份信息，而这些信息是服务器判别用户的唯一依据。
但若服务器要求客户端，每次发送请求时也必须带上另一个身份识别依据token。token是攻击者所不能伪造的信息，并且不存在于Cookie当中。
那么CSRF仅靠Cookie是无法获取服务器信任的。

4.响应头set-cookie的SameSite属性
用来标明这个Cookie是个“同站Cookie”，SameSite可取值为：
-strict: 完全不使用第三方cookie。（那么我们在B站点下发起对A站点的请求，A站点的Cookie不会包含在请求头中）
-laz: 允许安全的HTTP请求带上Cookie，例如GET/OPTIONS/HEAD请求；POST/PUT/DELETE请求则不行，另外iframe，ajax，image也不行？


----------------------------------------------------------点击劫持---------------------------------------------------

1.攻击者构建了一个非常有吸引力的网页，将被攻击放置在此页面的iframe中
2.使用样式将iframe叠加到非常有吸引力内容的上方，并将iframe设置为100%透明
2.用户被诱导点击了网页内容，实际上点的是被攻击页面

防御一：frame busting
if ( top.location != window.location ){
    top.location = window.location
}
注意：HTML5中iframe的 sandbox 属性、IE中iframe的security 属性等，都可以限制iframe页面中的JavaScript脚本执行，从而可以使得 frame busting 失效

防御二：X-Frame-Options
是微软提出的一个http头，专门用来防御利用iframe嵌套的点击劫持攻击。可选值有：
-DENY: 拒绝任何域加载
-SAMEORIGIN: 允许同源域下加载
-ALLOW-FROM: 可以定义允许frame加载的页面地址

--------------------------------------------------

安全扫描工具推荐：Arachi / Mozilla HTTP Observatory / w3af



