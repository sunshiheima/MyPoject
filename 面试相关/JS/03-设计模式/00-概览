【开放封闭原则】—— 在【抽象工厂模式】处提到的
    即开放[拓展]封闭[修改]原则：即软件实体(类、模块、函数)可以拓展，但是不可修改。
    //当我们需要添加功能时，我们首先想到的就是修改，这是错的，我们应该做的是【拓展】

【单一职责原则】—— 在【装饰器模式】处提到的
    在日常开发中，当遇到两段各司其职的代码逻辑时，我们首先要有“尝试拆分”的敏感，其次要有“该不该拆”的判断。
    当逻辑粒度过小时，盲目拆分会导致你的项目里存在过多零碎的小方法，这反而不会使我们的代码变得更好。

--------------------------------------------------------------------------------------------

构造器模式：解决多个实例对象的问题；简单工厂模式：解决多个构造函数的问题；抽象工厂模式：解决多个工厂函数的问题(构建一个超级工厂)
单例模式(重)：【唯一的Storage】、【唯一的Modal弹框】
原型模式：即原型范式(原型+原型链)，Object.create()、【递归实现深拷贝】
装饰器模式(重)：【ES7装饰器语法糖】、【React高阶组件HOC】、【改变redux/connect的用法】、非常赞的装饰模式库core-decorators
适配器模式：【兼容老接口-新fetch兼容老XMLHttpRequest】、【axios内部的适配器-如何实现跨平台的】
代理模式(重)：【科学上网VPN-仅概念】、【保护代理(即添加检验和拦截)】、【事件代理(即事件委托)】、【虚拟代理(图片预加载)】、【缓存代理(对传入的参数求和，直接获取之前计算的结果)】。
策略模式和状态模式：单一职责原则(把做某件事的代码放在某个函数当中)+开放[拓展]封闭[修改]原则(软件实体(类、模块、函数)可以拓展，但是不可修改。建议用对象映射代替if-else)
迭代器模式(重)：就是遍历。ES6之前的forEach只能遍历数组，通用迭代器只有JQ的each；ES6之后【Iterator】，【for-of，内部也是Iterator】，【手写一个iteratorGenerator】
观察者模式和发布订阅者模式(重)：前者无第三方，应用有【Vue数据双向绑定(响应式系统)的原理】；后者有第三方，应用有【Vue的EventBus/EventEmitter实现】

-------------------------------------------------------------------------------------------

设计模式(小册)：

核心竞争力：
—能用健壮的代码去解决具体的问题
—能用抽象的思维去应对复杂的系统(架构师)
—能用工程化的思想去规划重大规模的业务(架构师)

要掌握靠谱开发，先掌握设计模式
先根据问题场景判断需使用那种设计模式，然后再默写设计模式模板。

设计模式的五大原则中最常用的：单一功能和开放封闭。

设计模式的核心思想—封装变化：将变与不变相分离，确保变化的部分灵活、不变的部分稳定。

设计模式被分为了“创建型”、“结构型”、“行为型”
-创建型模式：封装了创建对象过程中的变化，它做的事情就是将创建对象的过程抽离。
-结构型模式：封装了对象之间组合方式的变化，目的在于灵活的表达对象间的配合与依赖关系。
-行为型模式：将对象千变万化的行为进行抽离，确保我们能够更安全、更方便的对行为进行更改。

设计模式的前端化：场景是基础、代码是辅助、逻辑是主角

-------------------------------------------------------------------------------------------

设计模式(书)
书籍来源：腾讯Alloy Team出品的《JavaScript设计模式与开发实践》
基础知识：原型、this/call/apply、闭包和高阶函数
思维特点：从【类似于Java类的原型】开始讲述单例模式的实现，但实则JavaScript是一门“无类”的语言。后面过渡到更适合JS的【巧妙地用函数来实现】
疑惑：感觉设计模式不怎么好用到react当中去，因为react鼓励用声明式的写法，而设计模式用的是命令式的写法！问一下面试官有什么好的建议！
