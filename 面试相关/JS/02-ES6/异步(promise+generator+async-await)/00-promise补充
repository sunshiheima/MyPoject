只是写了一部分需要注意的（之前有遗漏的问题），具体见文（文中也指说了一部分，可以看一下，最开始有关异步的描述还是不错的!）
https://juejin.im/post/6844903775329583112#heading-20

Promise使用建议：
1.工作中建议全面拥抱新的Promise语法，其实现在的异步编程基本也都使用的是Promise
2.建议使用ES7的async/await进一步的优化Promise的写法
  async函数始终返回一个Promise，await可以实现一个"等待"的功能，async/await被成为异步编程的终极解决方案
  即用同步的形式书写异步代码，并且能够更优雅的实现异步代码顺序执行以及在发生异步的错误时提供更精准的错误信息
3.只是了解这些API，却不知道Promise内部具体是怎么实现的，遇到复杂的异步代码就无从下手
   非常建议去了解一下Promise A+的规范，自己实现一个Promise

----------------------------------------------------------------------------

1.回调函数会有信任问题
//下面fn表示第三方库中的某方法，是异步的
fn(参数1，参数2，我们的回调函数）
fn内部的具体实现我们并不清楚，其内部会在合适的时机调用【我们的回调函数】
故我们的回调函数是交给第三方调用的，调用多少次我们都不知道。

2.Promise解决信任问题
let promise = new Promise((resolve, reject) => {
	fn(参数1，参数2，resolved，reject）	
	//fn是第三方库中的某方法，是异步的
	//我们并未将【我们的回调函数】直接传给第三方库让其调用，而是只给它传入了resolve和reject两个方法
	//在第三方库中，调用这两个方法，并且将【我们所需要的内容，也是要传给我们的回调函数的内容】作为参数传入resolve/reject
	//这样（下面注册的）【我们的回调函数】就能够接收到内容了
})
promise.then(res => {	//我们将【我们的回调函数】放到then方法中来了，即回调函数的执行由我们来控制了！
	console.log(res);
})

重！！！愈发感觉其实Promise就是一个装着异步行为的容器而已！！！

错误处理分析同上！

-------------------------------------------------------------------------------

现代前端大部分的异步请求都是使用Promise实现的，fetch这个web api也是基于Promise的。
Promise并不是回调函数的衍生版本，而是两个概念。
现在MVVM框架常用的第三方请求库也是基于Promise的，另外nodejs中也有bluebird和Q等。

--------------------------------------------------------------------------------

执行了resolve函数后不一定会进入fullfilled状态！

let promise = new Promise(resolve => {
	resolve(Promise.reject('报错了'));
})
//注意这里用一个定时器在下轮事件循环中打印这个Promise实例的状态,否则会是pending状态
setTimeout(() => {
	console.log(promise);	//Promise {<rejected>: '报错了'}
})

上面调用了resolve函数，仍返回了一个拒绝状态的Promise
因为如果在一个promise的resolve函数中又传入了一个Promise,会展开传入的这个promise
这里因为传入了一个拒绝状态的promise,resolve函数展开这个promise后,就会变成一个拒绝状态的promise,所以把resolve理解为决议比较好一点

等同于：
let promise = Promise.reject('报错了');
setTimeout(() => {
	console.log(promise);	//Promise {<rejected>: '报错了'}
})


