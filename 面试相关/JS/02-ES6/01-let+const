1.块级作用域
ES5中作用域只有全局作用域和函数作用域。
到了ES6，let/const还能创建块级作用域。（即其所在的花括号内就是一个新的作用域）
外部是访问不到该块级作用域内用let/const声明的变量的。

2.if/for结合let/const 的使用注意：
使用时多存在于【if/for结合let/const】创建的块级作用域。注意使用let/const声明变量的for循环和var声明的有些不同。
//for循环：
for循环包含两大块：小括号中的为【设置循环变量部分】，大括号中的为【循环体部分】
实则：【设置循环变量部分】是一个父作用域，而【循环体部分】是一个单独的子作用域，所以我们可以在循环体内部访问到i的值。
for循环【设置循环变量部分】又包含3个部分：第一部分包含一个变量声明，第二部分包含一个循环的退出条件，第三部分包含每次循环最后要执行的表达式。后面的两个部分在每次循环时都会执行一遍。区别在于变量声明。
//使用var声明循环变量：
只会声明一次
//使用let声明循环变量：
每次循环都会声明一次
每一次循环的i其实都是一个新的变量，JavaScript引擎内部会记住上一轮i的值，初始化本轮的i时，会上一轮循环的基础上进行计算。

3.暂时性死区
//一个变量，仅仅在创建之后还不能用（用了会报错），在初始化之后才能用。    //所谓的“用”，就是访问/修改
从【创建】到【初始化】之间的代码就形成了【暂时性死区】，已经被创建的变量不能在这段代码内被访问或修改。

简述：
var声明的变量：在预编译阶段就会【被创建】&&【被初始化为undefined】；在代码执行阶段会【重新赋我们指定的值】
let/const声明的变量：在预编译阶段只会【被创建】，不会被初始化；在代码执行阶段在声明语句（"let name"）之前，均不会被【初始化】。
                    因此在声明语句之前，会形成【暂时性死区】，即不能访问或修改let/const声明的变量。
                    只有当执行到声明语句时，若是let声明的且没有赋值，就会默认初始化为undefined；若是const声明的且没有赋值，则会报错。
                    let和const都不能重复声明

4.let和const的区别：
let在声明的时候可以不赋值，那么默认初始化为undefined。后面还可以重新赋值（但不能重新声明）。
const在声明的时候必须被赋值，且赋值之后变量指向的内存地址不能被改变（不能再使用赋值运算符改变）
-若赋予的是一个基本类型，那么所谓内存地址也就是该基本类型的值；
-若赋予的是一个引用类型，那么内存地址实则为一个对象的引用。只要保证该内存地址不变即可，引用的对象还可以改变（对属性增删改）。
 即可以对属性增删改，但不能直接使用赋值运算符更改，因为这种更改本质上会改变内存地址引用的那个对象。

另外：let和const声明的变量不会变为全局变量（即不会被挂到window上，故不会污染全局变量空间）
//其实let声明的变量是在一个叫script作用域下的

5.let和const的使用建议：
let：用于一般的变量声明
const：用于声明一些配置项（接口地址、npm依赖包、分页器默认页数等一旦声明后就不会改变的变量），用于显式的告诉其他开发者该变量是不能改变的。
       建议使用【全大写字母+单词间用下划线】

       






--------------------------------------------------下面供深挖时参考-------------------------------------------------------------------

【临时性死区】具体概述：
1.var声明的变量，在代码执行到什么的时候：
  1).先进入预编译阶段：会创建什么作用域、什么环境、name变量。
                      name变量还会提升到当前函数作用域的顶部（如果"var name"是在全局作用域下,则name变量会直接提升到全局作用域），并且【赋值】为undefined
                      //故var声明的变量在预编译时，会被创建并赋值为undefined
  2).进入代码执行阶段：当运行到"name = 'abc'"这句代码时，name变量会被重新赋值为'abc'

2.因为使用了let声明了变量name，因此在代码执行到if语句的时候：（重点！）
  1).先进入预编译阶段：一次创建块级作用域、词法环境、name变量（创建了但是没有初始化）
  2).进行代码执行阶段：只有运行到“let name”这一句代码时变量才被初始化并赋值为undefined。
                      但是在这一句代码之前name变量仅仅被创建了（在预编译阶段）但是未被初始化。在此之前使用该变量

-------下面为有疑惑的部分--------------
//文中描述，意思就是【3.临时性死区】的意思

let/const也有提升的作用，但是和var的区别在于：
-var在【创建】时就被【初始化】，并且赋值为undefined
-let/const在进入块级作用域后，会因为提升的原因先【创建】，但不会被初始化，直到声明语句执行时才被【初始化】。
 初始化时如果使用let声明的变量没有赋值，则会默认赋值为undefined；而const必须在初始化的时候赋值，否则会报错。

边解释边执行、预编译、执行？
什么叫声明提升？其本质究竟是什么？

var的缺陷：变量提升、污染全局变量等

需要去查：JS预编译 && JS的三种作用域（全局、函数、块级）

--------------------------------------