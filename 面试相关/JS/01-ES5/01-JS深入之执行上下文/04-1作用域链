【执行上下文栈】中讲到，当执行一段可执行代码时，会创建对应的执行上下文。
对于每个执行上下文，都有三个重要属性：
1.变量对象(VO, Variable object)
2.作用域链(Scope chain)
3.this

作用域链：
1.在查找变量的时候，会先从当前上下文的变量对象中查找，
2.如果没有找到，就会从父级（【词法层面】的父级）执行上下文的变量对象中查找，一直找到全局上下文的变量对象，也就是全局对象window.
  注意：！上一行表述中说的：词法层面的父级，也就是说我们看作用域链的时候，看的也是函数定义时所在位置（的父级），而不是函数执行时所在位置（的父级）

--------------------------------------------------
下面以一个【函数的创建】和【激活】两个时期来讲解作用域链时如何创建和变化的：

1.函数创建
之间讲到过，函数的作用域在函数定义的时候就决定了
这是因为函数有一个内部属性[[scope]]，当函数创建的时候，就会保存所有父变量对象到其中，你可以理解[[scope]]就是所有父变量对象的层级链。
但是注意：[[scope]]并不代表完整的作用域链！

2.函数激活
当函数激活时，进入函数上下文，创建变量对象(VO/AO)后，就会将活动对象添加到作用域链的前端。
这时候执行上下文的作用域链，我们命名为Scope:
Scope = [AO].concat([[scope]]);
至此，作用域链创建完毕！

//重写上面
1.函数创建
当函数父级的执行上下文被初始化时，函数就会被创建，并会保存 所有父级作用域链 到 函数自身的属性[[scope]]

2.初始化函数执行上下文
//函数被调用时不会立即执行其内部代码，而会先做准备工作即创建函数执行上下文；
当初始化函数执行上下文时，会先将属性[[scope]]复制到作用域链Scope当中
创建活动对象(VO/AO)后，会将活动对象添加到作用域链Scope的顶端
