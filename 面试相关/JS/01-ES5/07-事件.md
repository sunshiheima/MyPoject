# 1 关键字：

```text
1.事件冒泡、事件捕获 + 事件流
2.事件委托
3.移除事件处理程序（onunload 中移除）
4.添加事件处理函数的方式：HTML、DOM0 级、DOM2 级
5.事件对象 event（currentTarget、target、type、preventDefault()、stopPropagation()）
```

------------------------------------------事件冒泡和事件捕获+事件流--------------------------------------------------

# 2【事件冒泡、事件捕获】

- [事件冒泡]会从当前触发的事件目标一级一级往上传递，依次触发，直到 document 为止。
- [事件捕获]会从 document 开始触发，一级一级往下传递，依次触发，直到真正事件目标为止。
  （IE 只支持事件冒泡，不支持捕获）

## 2.1 “DOM2 级事件”规定的【事件流】包括三个阶段：

事件捕获阶段、处于目标阶段、事件冒泡阶段

- 1)首先发生事件捕获（为截获事件提供了机会）
- 2)然后是实际的目标接收到事件
- 3)-最后冒泡阶段，可以在这个阶段对事件做出响应

规范要求：捕获阶段不会涉及到事件目标
但实际上：很多浏览器都会在捕获阶段在目标对象上面操作事件（所以实则有两次机会在目标对象上操作事件）

[注意]
在事件处理程序中删除目标元素（比如按钮），可以阻止事件冒泡。因为目标元素在文档中是事件冒泡的前提。

# 3 事件委托

## 3.1【不用事件委托】

需要对每一个元素都添加事件处理程序

- 必须先获取 DOM 元素，才能为其添加事件处理程序。需获取每一个 DOM 元素则 DOM 访问次数多
- 每个事件处理函数都是对象，函数多则占用内存多

## 3.2【事件捕获】

是利用了事件冒泡。无需对每一个元素都添加事件处理程序，只需在 DOM 树中尽量最高的层次上添加一个事件处理程序。
适合采用事件委托的事件包括：多数鼠标事件和键盘事件（click、mousedown、mouseup、keydown、keyup、keypress）

## 3.3【为 document 对象添加一个事件处理程序】

好处是：document 对象很快就可以访问到，而且可以在页面生命周期的任何时点上为它添加事件处理程序（无需等待 DOMContentLoaded 事件或 load 事件）
即只要可单击的元素呈现在页面上，就可以立即具备适当的功能。

## 3.4【代码实现事件委托机制？】

红宝书上是 EventUtil，但无具体实现（有 addHandler()、getEvent()、getTarget()，根据 target.id 来找到具体应被处理的元素）

# 4 移除事件处理程序

## 4.1【事件处理程序带来的问题】

若为一个元素添加了事件处理程序，即使这个元素被删除了(removeChild()、replaceChild()、使用 innerHTML 替换)，该事件处理程序依然存在，占用内存。
如果在页面被卸载之前没有清理干净事件处理程序，那它们就会滞留在内存中。
每次加载页面再卸载页面时（在两个页面间来回切换/点击“刷新”按钮），内存中滞留的对象数目就会增加。

## 4.1【解决方案】

在页面卸载之前，先通过 onunload 事件处理程序移除所有事件处理程序。（btn.onclick = null;）
添加事件的时候使用事件委托，也可以方便我们清除事件。
（但是使用 onunload 事件处理程序意味着页面不会被缓存到 bfcache 中）

bfcahce(back-forward-cache 往返缓存)
可以在用户使用浏览器的“后退”和“前进”按钮时加快页面的转换速度。
这个缓存不仅保存页面数据，还保存了 DOM 和 JS 的状态，实际上是将整个页面都保存在内存里。
如果页面位于 bfcache 中，那么再次打开该页面就不会触发 onload 事件
[个人觉得] 在元素删除是 相应的事件一并删除

# 5 添加事件处理程序的方式

## 5.1 HTML 事件处理程序：

将事件以属性的形式添加到 HTML 元素标签中 -<input onclick="alert('xxx')" /> -<input onclick="show()" />

- 1)事件处理程序中的代码在执行时，有权访问全局作用域中的任何代码
- 2)会创建一个封装着元素属性值的函数。这个函数中有:
  - 2.1)一个局部变量 event，也就是【事件对象】
  - 2.2)this：值等于事件的目标元素
  - 2.3)可以像访问局部变量一样访问 document
  - 2.4)如果当前元素是表单输入元素(input)，那么可直接访问表单元素(父元素 form)

缺点： -存在时差问题（在代码尚未执行到事件处理函数，事件处理函数尚未声明时，若触发事件就会报错）（用 try-catch 捕获错误）
-HTML 和 JS 代码紧密耦合，要更换一个事件处理程序，就必须改动 HTML 和 JS 代码

---

## 5.2 DOM0 级事件处理程序：

将函数赋值给一个事件处理程序属性

- 以这种方式添加的事件处理程序会在事件流的冒泡阶段被处理
- 事件处理函数内部的 this 指向当前元素（使用 DOM0 级方法指定的事件处理程序被认为是元素的方法，此时事件处理程序会在元素的作用域中运行）
  [优点]：各浏览器中实现无差异
  [缺点]：对每个事件只支持一个事件处理程序
  ```js
  <button id="btn"></button>
  var btn = document.getElementById("btn"); //要使用 JS 指定事件处理程序，首先必须取得一个要操作的对象的引用
  btn.onclick = function(){...}
  btn.onclick = null;
  ```

---

## 5.3 DOM2 级事件处理程序：

DOM2 级定义了两个方法。

- 1)添加事件 addEventListener、
- 2)删除事件 removeEventListener

### 5.3.1 接收的第三个参数:

- 1. 事件类型
- 2)事件处理函数 内部 this 指向当前元素（与 DOM0 级方法一样，添加的事件处理函数也是在其依附的元素的作用域中运行）
- 3. 是一个布尔值：true 表示在捕获阶段调用事件处理函数；false 表示在冒泡阶段调用事件处理函数(建议)

[优点]可以为同一个元素的同一个事件，添加多个事件处理程序。会按顺序依次触发。

```js
var btn = document.getElementById("btn");
var handler = function(){...}
btn.addEventListener("click", handler, false);
btn.removeListener("click", handler, false);
```

【IE 和 Opera】 -事件处理程序都会被添加到冒泡阶段
-this 指向 window，因为事件处理函数会全局作用域运行 -也可添加多个，但是不是按顺序触发，而是按相反的顺序被触发
btn.attachEvent("onclick", handler); //注意是事件名是 onclick 而非 click
btn.detachEvent("onclick", handelr);

【跨浏览器的事件处理程序】
。。。见下一个 js 文件

# 6 事件对象 event

在触发 DOM 上的某个事件时，会产生一个事件对象 event，浏览器会将其传入事件处理函数中（DOM0 级/DOM2 级）。当事件处理程序执行完毕，event 对象会被销毁。
event 包含所有与事件有关的信息：导致事件的元素、事件的类型、其他与特定事件相关的信息（如鼠标操作的 event 中有鼠标位置的信息、如键盘操作的 event 中有按下的键相关信息）
所有浏览器都支持 event 对象，但支持方式不同。

各个事件的 event 对象共有的属性和方法：

- 1)currentTarget
  Element，其事件处理程序当前正在处理事件的那个元素 //事件处理函数内部的 this 始终等于 currentTarget 的值
- 2)target
  (IE 中是 srcElement) Element，事件的实际目标（就是我们手动自己点击的那个元素） //只有目标元素的事件处理程序中，target 才会等于 currentTarget/this
- 3)type //String，被触发的事件的类型
- 4)eventPhase //确定事件当前位于事件流的哪个阶段（1-捕获阶段、2-处于目标、3-冒泡阶段）
- 5)preventDefault() //(IE 中是 returnValue) 取消事件的默认行为
- 6)stopPropagation() //(IE 中是 cancelBubble) 取消事件的捕获或冒泡

//type: 当需要通过一个函数处理多个事件时
。。。代码见下一个文件

【IE 中的事件对象 event】
。。。。。。

如何阻止事件冒泡：
event.stopPropagation();
// IE 里阻止冒泡
window.event.cancelBubble = true;

阻止默认事件：
event.preventDefault();
