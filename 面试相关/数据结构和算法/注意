1.我们知道递归比较容易造成栈溢出，所以如果有其他时间/空间复杂度相近或更好的算法，
  我们应该优先选择非递归的解法！

2.注意有关数字或者字符串的相关API【是否能连续调用】&&【最后是否需要一个变量接收】的问题
-能连续调用的情况：即调用API的返回结果是我们想要的（跟是否会改变原数组无关）
-无法连续调用的情况：即调用API返回结果不是我们想要的，而是该API会改变数组，改变之后的数组才是我们想要的！我们就需要在API被调用前后断开连续调用！
-需要一个变量接收的情况：我们最终想要的是，调用最后一个API之后的返回值
-不需要一个变量接收的情况：调用的这最后一个API会改变数组，我们需要的是这个改变之后的数组！

3.在面试的时候可以提及一下JS数组和常规数组的区别：
在大多数计算机语言中，数组都对应着一段连续的内存，那么数组增加/删除操作对应的时间复杂度为O(n)
但是在JS中不一定是
JS比较特别，如果我们在一个数组中只定义了一种类型的元素，比如const arr = [1,2,3,4]，它是一个纯数字数组，那么对应的确实是连续内存。
但如果我们定义了不同类型的元素，比如const arr = ['haha', 1, {a:1}]，它对应的就是一段非连续的内存。此时JS数组不再具有数组的特征，其底层使用【哈希映射】分配内存空间，是由对象链表来实现的。

可能会作为【数据结构选型的依据】来考察：
链表的插入/删除效率较高，而访问效率较低；而数组的访问效率较高，插入/删除效率较低