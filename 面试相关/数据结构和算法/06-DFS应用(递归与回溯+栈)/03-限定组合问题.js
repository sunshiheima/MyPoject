/*
【限定组合问题】
题目：给定两个整数 n 和 k，返回 1 ... n 中所有可能的 k 个数的组合。
示例：
    输入：n=4, k=2
    输出：[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]

注意：
    这道题虽然没有直接给出一个nums数组，而是直接约定了数字的范围为1-n，但其本质仍然是一个数字集合，我们只需稍微调整下取值方式即可

----------------下面仅了解即可-------------------

限定组合问题：及时回溯，即为“剪枝”

在寻找这三对节点的过程中，我们一旦找到一对，就停止继续往深处搜索，这就意味着一些节点压根没有机会被遍历到。
这其实就是“剪枝”的过程，在深度优先搜索中：
  【有时我们会去掉一些不符合题目要求的、没有作用的答案，进而得到正确答案】
  【这个丢掉答案的过程，形似剪掉树的枝叶，所以这已方法被称为“剪枝”】

要做到“剪枝”，我们需要分别在组合问题的【递归式】和【递归边界】上做手脚：
1.递归式：普通组合问题，每到一个新的坑位处，我们都需要对组合结果数组进行更新；
        这道题中，当且仅当数字个数为k个时，才会对组合结果数组进行更新
2.递归边界：只要组合内数字个数达到了k个，就不再继续当前的路径往下遍历，而是直接返回！

*/

const combine = function (n, k) {
  // 初始化结果数组
  const res = [];
  // 初始化组合数组
  const subset = [];
  // 进入 dfs，起始数字是1
  dfs(1);

  // 定义 dfs 函数，入参是当前遍历到的数字
  function dfs(index) {
    if (subset.length === k) {
      res.push(subset.slice());
      return;
    }
    // 从当前数字的值开始，遍历 index-n 之间的所有数字
    for (let i = index; i <= n; i++) {
      // 这是当前数字存在于组合中的情况
      subset.push(i);
      // 基于当前数字存在于组合中的情况，进一步 dfs
      dfs(i + 1);
      // 这是当前数字不存在与组合中的情况
      subset.pop();
    }
  }
  // 返回结果数组
  return res;
};

const combine = function (n, k) {
  const res = [];
  const subset = [];
  dfs(1);
  function dfs(index) {
    if (subset.length === k) {
      res.push(subset.slice());
      return;
    }
    for (let i = index; i <= n; i++) {
      subset.push(i);
      dfs(i + 1);
      subset.pop();
    }
  }
  return res;
};
