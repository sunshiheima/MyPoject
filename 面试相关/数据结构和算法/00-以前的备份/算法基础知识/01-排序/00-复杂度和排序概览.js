/*
  时间复杂度：
    一个算法的时间复杂度反映了程序从开始到结束所需要的时间，把算法中基本操作重复执行的次数（频度）作为算法的时间复杂度

  例如：
  没有循环语句，记作O(1)，也称为常数阶。
  只有一重循环，则算法的基本操作的执行频度与问题规模n呈线性增大关系，记作O（n），也叫线性阶。

  空间复杂度：
    一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计
    一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间

*/

/*
  排序概览：
    （前端接触最多的算法）
    排序的方法有很多，它们各自有各自的应用场景和优缺点。在此推荐6中应用最多的排序方法。
    1.快速排序    不稳定
      选择一个目标值，比目标值小的放左边，比目标值大的放右边。先将目标值的位置排好之后，再将左右两侧进行快排。
    2.归并排序   稳定
      将大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列
    3.选择排序    不稳定
      每次排序取一个最大或者最小的数字放到前面的有序序列中
    4.插入排序    不稳定
      将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位
    5.冒泡排序    稳定
      循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序的好的数
    6.堆排序
      创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。
*/